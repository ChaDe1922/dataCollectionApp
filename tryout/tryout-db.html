<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="gsds-api-base" content="https://script.google.com/macros/s/AKfycbw8Jb7RpQ7j9L2q32YDSBuNSPLFMjPzKdvuI_BgkutfNk5COrEYUdsUWZYXDOJRAeH3kA/exec">
  <title>DB Station — Tryouts</title>

  <!-- Simple auth guard -->
  <script>
    (function(){
      const ok = localStorage.getItem('auth_ok')==='1' &&
                 Number(localStorage.getItem('auth_until')||0) > Date.now();
      if(!ok){ window.location.href = '../index.html#login'; }
    })();
  </script>

  <!-- Theme + fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css"/>

  <style>
    .container{ max-width:1100px; margin:0 auto; padding:16px; }
    .grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    @media (max-width:900px){ .grid-2{ grid-template-columns:1fr; } }

    .card{ background: rgba(255,255,255,.05); border:1px solid var(--border);
           border-radius:16px; padding:16px; box-shadow: var(--shadow-soft, 0 8px 24px rgba(0,0,0,.18)); }
    .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
           border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); font-weight:700; }
    .chip.badge{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .chip.ghost{ background:transparent; }

    .assign{ display:flex; align-items:center; gap:8px; margin-left:auto; }
    .seg{ display:inline-flex; background:rgba(255,255,255,.06); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    .seg button{ appearance:none; border:0; padding:6px 10px; font-weight:800; color:#fff; background:transparent; cursor:pointer; }
    .seg button[aria-pressed="true"]{ background:#8B5CF6; color:#071018; }

    .field{ margin:10px 0; }
    .label{ font-weight:800; font-size:.95rem; opacity:.9; margin-bottom:6px; display:block; }
    .form-input, .form-select{ width:100%; padding:.68rem .8rem; border-radius:12px; border:1px solid rgba(255,255,255,.28);
      background:rgba(255,255,255,.08); color:#fff; }

    .timer{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .time{ font-variant-numeric:tabular-nums; font-weight:900; font-size:1.25rem; min-width:82px; text-align:right; }

    .btn{ appearance:none; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:#fff;
          padding:.55rem .8rem; border-radius:10px; font-weight:800; cursor:pointer; transition: all .2s ease; }
    .btn.primary{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .btn.success{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; border:0; }
    .btn.warn{ background:linear-gradient(135deg,#F59E0B,#F59E0B); color:#2A1400; border:0; }
    .btn.ghost{ background:transparent; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    /* Counter control */
    .counter-control { display:flex; align-items:center; gap:8px; }
    .counter-btn{
      width:40px; height:40px; display:flex; align-items:center; justify-content:center;
      border-radius:8px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08);
      color:#fff; font-size:20px; font-weight:800; cursor:pointer; transition:all .2s ease; user-select:none;
    }
    .counter-btn:hover{ background:rgba(255,255,255,.15); transform:scale(1.05); }
    .counter-btn:active{ transform:scale(0.95); }
    .counter-value{ min-width:60px; text-align:center; font-size:24px; font-weight:900; color:#C4B5FD; font-variant-numeric:tabular-nums; }

    /* Rate display */
    .rate-display{ margin-top:8px; padding:8px 12px; background:rgba(139,92,246,.15);
      border:1px solid rgba(139,92,246,.3); border-radius:8px; text-align:center; }
    .rate-value{ font-size:28px; font-weight:900; color:#C4B5FD; font-variant-numeric:tabular-nums; }
    .rate-label{ font-size:11px; opacity:.7; margin-top:2px; }

    /* Save indicator */
    .btn.loading{ position:relative; pointer-events:none; }
    .btn.loading .spin{ width:14px; height:14px; border:2px solid rgba(255,255,255,.45);
                        border-top-color:#fff; border-radius:50%; display:inline-block;
                        margin-right:8px; vertical-align:-2px; animation:spin .8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .lane-title{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:900; letter-spacing:.04em; opacity:.9; }
    .lane-chip{ display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px;
                border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); font-weight:800; font-size:.9rem; }
    .lane-chip .x{ opacity:.7; cursor:pointer; padding:0 .25rem; }

    .lane-card{ transition: box-shadow .15s ease, border-color .15s ease; }
    .lane-card.lane-active{ border-color:#8B5CF6; box-shadow:0 0 0 2px rgba(139,92,246,.35) inset; }

    .small{ font-size:.85rem; opacity:.8; }
    .status{ margin-top:8px; font-weight:700; }
    .status.ok{ color:#34D399; } .status.err{ color:#F87171; } .status.warn{ color:#F59E0B; } .status.avg{ color:#8B5CF6; }

    .table{ width:100%; border-collapse:collapse; font-size:.95rem; }
    .table th,.table td{ padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12); text-align:left; }

    .rating-above{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-avg{   background:linear-gradient(135deg,#8B5CF6,#A78BFA); color:#071018; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-below{ background:linear-gradient(135deg,#DC2626,#EF4444); color:#fff;    padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }

    .measure-help{ font-size:11px; opacity:.7; font-weight:500; margin-top:2px; font-style:italic; }
  </style>
</head>

<body class="theme-atl practice-page">
  <header class="page-header">
    <h1>DB Station</h1>
    <nav class="menu-actions">
      <a class="menu-btn" href="../index.html">Home</a>
      <a class="menu-btn" href="../tryout/index.html">Tryout Hub</a>
    </nav>
  </header>

  <main>
    <div class="container">
      <!-- Shared: context bar, filter chips, roster chips (filter to DB) -->
      <div id="tryout-shared" style="margin-bottom:12px"></div>

      <!-- Top control bar -->
      <section class="card" style="margin-bottom:14px">
        <div class="toolbar">
          <span class="chip">Station: <strong>DB</strong></span>

          <div class="field" style="min-width:280px; margin:0;">
            <label class="label">DB Drill</label>
            <select id="dbDrillSel" class="form-select"></select>
            <div id="dbDrillHint" class="small muted" style="margin-top:6px"></div>
          </div>

          <span id="drillBadge" class="chip badge">Drill: —</span>

          <div class="assign" style="margin-left:auto">
            <span class="chip ghost small">Assign selection to:</span>
            <div class="seg" role="tablist" aria-label="Active lane">
              <button id="segA" role="tab" aria-pressed="true">Lane A</button>
              <button id="segB" role="tab" aria-pressed="false">Lane B</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <div>
            <label class="label">Player (search by number or name)</label>
            <input id="playerPicker" class="form-input" list="db_roster" placeholder="e.g., 7 • Jordan Cross"/>
            <datalist id="db_roster"></datalist>
          </div>
          <div>
            <label class="label">Notes (optional, applies to next save)</label>
            <input id="sharedNotes" class="form-input" placeholder="press/bail, hash/side, WR route, etc."/>
          </div>
        </div>

        <div class="toolbar" style="margin-top:10px;gap:12px">
          <span id="chipLaneA" class="lane-chip" style="display:none"></span>
          <span id="chipLaneB" class="lane-chip" style="display:none"></span>
          <span class="small muted">Time drills use a timer; rate drills use Good/Bad and auto-calc attempts. “Reps/Attempts” goals don’t affect rating.</span>
        </div>
      </section>

      <!-- Two lanes -->
      <section class="grid-2">
        <!-- LANE A -->
        <div id="laneA" class="card lane-card lane-active">
          <div class="lane-title">
            <span>Lane A</span>
            <span id="laneAWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="field">
            <label class="label">Attempt</label>
            <select id="aAttempt" class="form-select">
              <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
              <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
            </select>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="aTimerBlock">
              <label class="label">Primary: <span id="aPrimaryLabel">Time</span></label>
              <div class="measure-help" id="aPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="aTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="aToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="aReset">Reset</button>
              </div>
            </div>
            <div id="aInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="aSave" disabled>Save Attempt (A)</button>
            </div>
          </div>

          <div class="status" id="aStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="aHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="aLog"></tbody>
          </table>
        </div>

        <!-- LANE B -->
        <div id="laneB" class="card lane-card">
          <div class="lane-title">
            <span>Lane B</span>
            <span id="laneBWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="field">
            <label class="label">Attempt</label>
            <select id="bAttempt" class="form-select">
              <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
              <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
            </select>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="bTimerBlock">
              <label class="label">Primary: <span id="bPrimaryLabel">Time</span></label>
              <div class="measure-help" id="bPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="bTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="bToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="bReset">Reset</button>
              </div>
            </div>
            <div id="bInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="bSave" disabled>Save Attempt (B)</button>
            </div>
          </div>

          <div class="status" id="bStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="bHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="bLog"></tbody>
          </table>
        </div>
      </section>

      <!-- Start both (time drills only) -->
      <section id="bothStartCard" class="card" style="margin-top:8px; display:none">
        <div class="toolbar" style="justify-content:center">
          <button id="bothStart" class="btn primary">Start Both</button>
        </div>
      </section>

      <!-- Recent writes -->
      <section class="card" style="margin-top:14px">
        <div class="toolbar">
          <button id="toggleRecent" class="btn ghost">Recent Writes ▾</button>
          <span id="recentCount" class="small muted"></span>
        </div>
        <div id="recentPanel" style="display:none; margin-top:8px">
          <ul id="recentList" style="margin:0; padding-left:18px"></ul>
        </div>
      </section>
    </div>
  </main>

  <footer class="site-footer"><p>&copy; 2025 Game Speed Data Systems</p></footer>

  <!-- libs -->
  <script src="../js/api.js"></script>
  <script src="../js/rules.js"></script>
  <script src="../js/context.js"></script>
  <script src="../js/tryout-ui.js"></script>

  <script>
    // ---------- Boot shared context/UI ----------
    (function(){
      const meta = document.querySelector('meta[name="gsds-api-base"]');
      window.API_BASE = (meta && meta.content || '').trim();
    })();
    GameContext.configure({ apiBase: window.API_BASE, server: true, pollMs: 1000 });

    // DB group filter in the shared Tryout UI
    TryoutUI.init('#tryout-shared', { showGroup:true, filterMode:'groups', allowPresence:false });
    GameContext.setGroup('DB');

    // ---------- DB Station logic (dictionary-driven) ----------
    const STATION_ID = 'DB';
    const AFTER_SAVE = { clearLane:false, markDone:true };

    let roster = [];
    const groupLatest = new Map();
    const pageLog = [];
    const PAGE_LOG_LIMIT = 12;

    const lanePlayers = { A:null, B:null };
    let activeLane = 'A';
    const timers = new Map();
    let DB_DRILLS = [], DB_CURR = null;

    // ------- helpers -------
    const qs  = (s,p=document)=>p.querySelector(s);
    const qsa = (s,p=document)=>[...p.querySelectorAll(s)];
    const labelFor = (r)=> [r.tryout_num, '•', r.display_name, r.primary_pos?`(${r.primary_pos})`:'' ].filter(Boolean).join(' ');
    function ctx(){ return GameContext.get ? GameContext.get() : {}; }
    const fmtTime = (d)=>{ const pad=n=>String(n).padStart(2,'0'); return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };
    const pretty = s=>String(s||'').replace(/_/g,' ').replace(/\b\w/g,c=>c.toUpperCase());
    const isTimeDrill = d => /sec/i.test(String(d?.measurement_unit||''));
    const isRateDrill = d => /percentage|percent|rate/i.test(String(d?.measurement_unit||'')) || String(d?.drill_type||'').toUpperCase()==='RATE';

    // ------ Threshold parsing & evaluation ------
    function parseThreshold(str) {
      if (!str) return null;
      const s = String(str).trim();
      const rangeMatch = s.match(/^(-?\d+(?:\.\d+)?)\s*[-–]\s*(-?\d+(?:\.\d+)?)$/);
      if (rangeMatch) return { type: 'range', min: parseFloat(rangeMatch[1]), max: parseFloat(rangeMatch[2]) };
      const compMatch = s.match(/^(<=|>=|<|>|=|≤|≥)\s*(-?\d+(?:\.\d+)?)$/);
      if (compMatch) {
        const op = compMatch[1].replace('≤','<=').replace('≥','>=');
        return { type:'comp', op, value: parseFloat(compMatch[2]) };
      }
      if (!isNaN(parseFloat(s))) return { type:'comp', op:'>=', value: parseFloat(s) };
      return null;
    }
    function meetsThreshold(th, value) {
      if (!th || value == null) return null;
      if (th.type === 'range') return value >= th.min && value <= th.max;
      if (th.type === 'comp') {
        switch(th.op){
          case '<=': return value <= th.value;
          case '>=': return value >= th.value;
          case '<':  return value <  th.value;
          case '>':  return value >  th.value;
          case '=':  return value === th.value;
        }
      }
      return null;
    }
    function evaluateDrill(drill, primaryVal, secondaryVal){
      // Prefer centralized Rules if available
      try{
        if (window.Rules?.evaluateRep){
          const res = Rules.evaluateRep(drill, primaryVal, secondaryVal);
          if (res && typeof res.is_success==='boolean'){
            return {
              rating: res.is_success ? 'above' : (res.is_failure ? 'below' : 'average'),
              ratingText: res.is_success ? 'Above Average' : (res.is_failure ? 'Below Average' : 'Average'),
              ratingClass: res.is_success ? 'rating-above' : (res.is_failure ? 'rating-below' : 'rating-avg')
            };
          }
        }
      }catch(_){}

      // Local fallback: primary thresholds + optional secondary
      // If secondary is attempts/reps (goal), ignore for rating
      const ignoreSecondaryForRating = isRateDrill(drill) && /attempt|rep/i.test(String(drill.secondary_measurement||''));
      const primaryOk   = meetsThreshold(parseThreshold(drill.success_threshold), primaryVal);
      const primaryFail = meetsThreshold(parseThreshold(drill.failure_threshold), primaryVal);
      const secOk = ignoreSecondaryForRating ? true : (drill.secondary_threshold ? meetsThreshold(parseThreshold(drill.secondary_threshold), secondaryVal) : true);

      if (primaryOk && secOk) return { rating:'above', ratingText:'Above Average',  ratingClass:'rating-above' };
      if (primaryFail || !secOk) return { rating:'below',  ratingText:'Below Average', ratingClass:'rating-below' };
      return { rating:'average', ratingText:'Average', ratingClass:'rating-avg' };
    }

    // timers
    function makeTimer(timeEl, onState){
      let running=false, t0=0, acc=0, raf=null;
      const fmt = ms => (ms/1000).toFixed(2);
      const tick = ()=>{ const now=performance.now(); const ms=acc + (running ? (now-t0) : 0); timeEl.textContent = fmt(ms); if(running) raf=requestAnimationFrame(tick); };
      const start = ()=>{ if(running) return; running=true; t0=performance.now(); tick(); onState?.(true); };
      const stop  = ()=>{ if(!running) return; running=false; acc += performance.now()-t0; cancelAnimationFrame(raf); tick(); onState?.(false); };
      const reset = ()=>{ running=false; acc=0; cancelAnimationFrame(raf); tick(); onState?.(false); };
      const toggle= ()=> running ? stop() : start();
      tick();
      return { start, stop, reset, toggle, isRunning:()=>running };
    }

    // roster datalist
    async function loadRoster(){
      const res = await API.tryout.read.roster();
      if(!res?.ok) return;
      const tid = ctx().tryout_id || '';
      roster = (res.roster||[]).filter(r => !tid || String(r.tryout_id||'')===String(tid));
      const dl = document.getElementById('db_roster');
      dl.innerHTML = '';
      roster.forEach(r=>{
        const rec = {
          player_id: r.player_id || '',
          display_name: r.display_name || r.player_name || '',
          primary_pos: r.primary_pos || r.position || '',
          tryout_num: r.tryout_num || r.jersey_number || '',
          group_code: r.group_code || r.primary_pos || ''
        };
        const opt = document.createElement('option');
        opt.value = labelFor(rec);
        opt.dataset.pid = rec.player_id;
        dl.appendChild(opt);
      });
    }

    async function loadLatestGroups(){
      const res = await API.tryout.read.groupsLatest(ctx().tryout_id);
      if(!res?.ok || !Array.isArray(res.latest)) return;
      groupLatest.clear();
      res.latest.forEach(row => { if(row.player_id && row.group_code) groupLatest.set(String(row.player_id).trim(), String(row.group_code).trim()); });
    }
    function resolveGroupCode(pid, fallback, rec){
      if (pid) {
        const direct = groupLatest.get(String(pid).trim());
        if (direct) return direct;
        const r = roster.find(x => String(x.player_id).trim() === String(pid).trim());
        return r?.group_code || r?.primary_pos || fallback || '';
      }
      return rec?.group_code || rec?.primary_pos || fallback || '';
    }

    // Active lane highlight
    function setActiveLane(l){
      activeLane = (l==='B') ? 'B' : 'A';
      document.getElementById('segA').setAttribute('aria-pressed', activeLane==='A' ? 'true':'false');
      document.getElementById('segB').setAttribute('aria-pressed', activeLane==='B' ? 'true':'false');
      qs('#laneA').classList.toggle('lane-active', activeLane==='A');
      qs('#laneB').classList.toggle('lane-active', activeLane==='B');
    }
    document.getElementById('segA').addEventListener('click', ()=> setActiveLane('A'));
    document.getElementById('segB').addEventListener('click', ()=> setActiveLane('B'));
    qs('#laneA').addEventListener('click', ()=> setActiveLane('A'));
    qs('#laneB').addEventListener('click', ()=> setActiveLane('B'));

    // Resets
    function softResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Time`).textContent = '0.00';
      const t = timers.get(p); t && t.reset();

      // clear dynamic inputs
      const box = qs(`#${p}InputsBlock`);
      if (box){
        box.querySelectorAll('[data-counter-value]').forEach(el=> el.textContent='0');
        const rv=box.querySelector(`#${p}RateVal`); if(rv) rv.textContent='0%';
        const sc=box.querySelector(`#${p}SuccCount`); if(sc) sc.textContent='0';
        const ac=box.querySelector(`#${p}AttCount`); if(ac) ac.textContent='0';
      }
      qs(`#${p}Status`).textContent = '';
    }
    function hardResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Attempt`).value = '1';
      qs(`#${p}Log`).innerHTML = '';
      softResetLane(lane);
    }

    function renderLaneChips(){
      const a = lanePlayers.A, b = lanePlayers.B;
      const aEl = document.getElementById('laneAWho');
      const bEl = document.getElementById('laneBWho');
      const topA= document.getElementById('chipLaneA');
      const topB= document.getElementById('chipLaneB');

      if(a){
        const txt = `${a.tryout_num||''} • ${a.display_name||a.player_id}${a.primary_pos?` (${a.primary_pos})`:''}`;
        aEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="A">✕</span>`;
        aEl.style.display = '';
        topA.textContent = `Lane A: ${txt}`; topA.style.display = '';
        document.getElementById('aSave').disabled = false;
      } else {
        aEl.style.display = 'none'; topA.style.display = 'none';
        document.getElementById('aSave').disabled = true;
      }
      if(b){
        const txt = `${b.tryout_num||''} • ${b.display_name||b.player_id}${b.primary_pos?` (${b.primary_pos})`:''}`;
        bEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="B">✕</span>`;
        bEl.style.display = '';
        topB.textContent = `Lane B: ${txt}`; topB.style.display = '';
        document.getElementById('bSave').disabled = false;
      } else {
        bEl.style.display = 'none'; topB.style.display = 'none';
        document.getElementById('bSave').disabled = true;
      }

      document.querySelectorAll('[data-clear="A"]').forEach(x=> x.onclick = ()=>{ lanePlayers.A = null; renderLaneChips(); hardResetLane('A'); });
      document.querySelectorAll('[data-clear="B"]').forEach(x=> x.onclick = ()=>{ lanePlayers.B = null; renderLaneChips(); hardResetLane('B'); });
    }

    // Assign to active lane
    function assignToActiveLane(rec){
      lanePlayers[activeLane] = rec;
      document.getElementById('playerPicker').value = labelFor(rec);
      renderLaneChips();
      hardResetLane(activeLane);
    }

    // Selection sources
    window.addEventListener('tryoutui:select', (e)=>{
      const d = e?.detail?.player; if(!d) return;
      const hit = roster.find(r => r.player_id===d.player_id) || d;
      assignToActiveLane(hit);
    });
    document.getElementById('playerPicker').addEventListener('change', (e)=>{
      const txt = (e.target.value||'').toLowerCase();
      const hit = roster.find(r => labelFor(r).toLowerCase() === txt) ||
                  roster.find(r => String(r.tryout_num||'').toLowerCase() === txt) ||
                  roster.find(r => String(r.display_name||'').toLowerCase() === txt);
      if(hit) assignToActiveLane(hit);
    });

    // ---- Drill Dictionary hookup ----
    function renderInputs(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      const timerBlk = qs(`#${prefix}TimerBlock`);
      const inputBlk = qs(`#${prefix}InputsBlock`);
      const bothCard = qs('#bothStartCard');
      const primaryLabel = qs(`#${prefix}PrimaryLabel`);
      const primaryHelp = qs(`#${prefix}PrimaryHelp`);

      const pm=(drill.primary_measurement||'').toLowerCase();

      // Update primary label/help
      const friendly =
        pm.includes('clean') ? 'Clean Rate' :
        pm.includes('form_correct') ? 'Form Correct Rate' :
        pm.includes('technique') ? 'Technique Success Rate' :
        pm.includes('win') ? 'Win Rate' :
        isRate ? 'Success Rate' : (drill.primary_measurement || 'Time');

      primaryLabel.textContent = isRate ? `${friendly} (calculated %)` : (drill.primary_measurement || 'Time');

      const parts = [];
      if (drill.drill_category) parts.push(drill.drill_category);
      if (drill.success_threshold) parts.push(`Above Avg: ${drill.success_threshold}`);
      if (drill.failure_threshold) parts.push(`Below Avg: ${drill.failure_threshold}`);
      primaryHelp.textContent = parts.join(' • ');

      // Toggle timer vs inputs
      timerBlk.style.display = isTime ? '' : 'none';
      inputBlk.style.display = isTime ? 'none' : '';

      // Update table head
      const head = qs(`#${prefix}Head`);
      head.innerHTML = `<tr>
        <th>Drill</th><th>Att</th>
        <th>${pretty(drill.primary_measurement) || 'Primary'}</th>
        <th>${drill.secondary_measurement ? pretty(drill.secondary_measurement) : 'Secondary'}</th>
        <th>Rating</th>
      </tr>`;

      // Start Both only for time drills
      bothCard.style.display = isTime ? '' : 'none';

      // Build inputs if not time
      inputBlk.innerHTML = '';
      if (!isTime && isRate){
        const succId = `${prefix}Successes`;
        const failId = `${prefix}Failures`;

        // DB labels based on primary metric
        const successLabel =
          pm.includes('clean') ? 'Clean Reps' :
          pm.includes('form_correct') ? 'Correct' :
          pm.includes('technique') ? 'Good Reps' :
          pm.includes('win') ? 'Wins' : 'Good Reps';

        const failureLabel =
          pm.includes('clean') ? 'Errors' :
          pm.includes('form_correct') ? 'Incorrect' :
          pm.includes('technique') ? 'Bad Reps' :
          pm.includes('win') ? 'Losses' : 'Bad Reps';

        // If secondary is attempts/reps with a threshold, treat as goal chip (not part of rating)
        const secName = String(drill.secondary_measurement||'');
        const isGoalOnly = /attempt|rep/i.test(secName) && drill.secondary_threshold;
        const secT = isGoalOnly ? parseThreshold(drill.secondary_threshold) : null;
        const goalValue = (secT && secT.type==='comp') ? secT.value : null;
        const goalLabel = /rep/i.test(secName) ? 'reps' : 'attempts';

        inputBlk.innerHTML = `
          <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
            <div>
              <label class="label">${successLabel}</label>
              <div class="counter-control">
                <button class="counter-btn" data-counter-dec="${succId}" type="button">−</button>
                <div class="counter-value" data-counter-value="${succId}">0</div>
                <button class="counter-btn" data-counter-inc="${succId}" type="button">+</button>
              </div>
            </div>
            <div>
              <label class="label">${failureLabel}</label>
              <div class="counter-control">
                <button class="counter-btn" data-counter-dec="${failId}" type="button">−</button>
                <div class="counter-value" data-counter-value="${failId}">0</div>
                <button class="counter-btn" data-counter-inc="${failId}" type="button">+</button>
              </div>
            </div>
          </div>

          <div class="rate-display" style="margin-top:8px;">
            <div class="rate-value" id="${prefix}RateVal">0%</div>
            <div class="rate-label">${friendly} (<span id="${prefix}SuccCount">0</span> / Attempts: <span id="${prefix}AttCount">0</span>)</div>
          </div>
          <div class="small" style="margin-top:6px;">
            <span data-rate="${prefix}-goal" class="chip ghost small" style="display:${isGoalOnly?'inline-flex':'none'}"></span>
          </div>
        `;

        const update = ()=>{
          const s = parseInt(inputBlk.querySelector(`[data-counter-value="${succId}"]`)?.textContent||'0');
          const f = parseInt(inputBlk.querySelector(`[data-counter-value="${failId}"]`)?.textContent||'0');
          const att = s + f;
          const pct = att>0 ? (s/att)*100 : 0;

          inputBlk.querySelector(`#${prefix}RateVal`).textContent = pct.toFixed(1)+'%';
          inputBlk.querySelector(`#${prefix}SuccCount`).textContent = s;
          inputBlk.querySelector(`#${prefix}AttCount`).textContent = att;

          const goalEl = inputBlk.querySelector(`[data-rate="${prefix}-goal"]`);
          if (goalEl && goalValue!=null){
            const met = att >= goalValue;
            goalEl.textContent = met ? 'Goal met ✓' : `Goal ≥ ${goalValue} ${goalLabel}`;
            goalEl.classList.toggle('badge', met);
          }
        };
        inputBlk.querySelectorAll('[data-counter-inc],[data-counter-dec]').forEach(btn=>{
          const isInc = btn.hasAttribute('data-counter-inc');
          btn.addEventListener('click', ()=>{
            const id = btn.getAttribute(isInc ? 'data-counter-inc' : 'data-counter-dec');
            const el = inputBlk.querySelector(`[data-counter-value="${id}"]`);
            const cur = parseInt(el.textContent)||0;
            el.textContent = String(isInc ? cur+1 : Math.max(0,cur-1));
            update();
          });
        });
        update();
      }
    }

    async function loadDBDrills(){
      try {
        const res = await API.tryout.read.drills();
        if (res?.ok) {
          const all = res.drills || res.rows || [];
          DB_DRILLS = all.filter(d => {
            const pg = String(d.position_group || '').toUpperCase();
            const st = String(d.station_id || '').toUpperCase();
            return pg === 'DB' || st === 'DB' || st === 'DBS';
          });
        }
      } catch (e) { console.error('Error loading drills:', e); }

      // Fallbacks (from your list)
      if (!Array.isArray(DB_DRILLS) || !DB_DRILLS.length){
        DB_DRILLS = [
          { drill_id:'DB01', drill_name:'Backpedal Downhill — 45 Break', station_id:'DB', position_group:'DB', drill_type:'Time',
            drill_category:'Change of Direction', primary_measurement:'time', measurement_unit:'sec',
            success_threshold:'<=9.6', failure_threshold:'>=12.4' },
          { drill_id:'DB02', drill_name:'Backpedal 45 Zigzag', station_id:'DB', position_group:'DB', drill_type:'Time',
            drill_category:'Change of Direction', primary_measurement:'time', measurement_unit:'sec',
            success_threshold:'<=11.6', failure_threshold:'>=14.6' },
          { drill_id:'DB03', drill_name:'Hip Turns', station_id:'DB', position_group:'DB', drill_type:'Rate',
            drill_category:'Hips/Transitions', primary_measurement:'clean_rep_rate', measurement_unit:'percentage',
            success_threshold:'>=85', failure_threshold:'<=60',
            secondary_measurement:'errors_count', secondary_unit:'count', secondary_threshold:'<=1' },
          { drill_id:'DB04', drill_name:'Combo Drill', station_id:'DB', position_group:'DB', drill_type:'Rate',
            drill_category:'Technique/Footwork', primary_measurement:'technique_success_rate', measurement_unit:'percentage',
            success_threshold:'>=75', failure_threshold:'<=45',
            secondary_measurement:'errors_count', secondary_unit:'count', secondary_threshold:'<=2' },
          { drill_id:'DB05', drill_name:'Breakdown (Form)', station_id:'DB', position_group:'DB', drill_type:'Rate',
            drill_category:'Tackling Form', primary_measurement:'form_correct_rate', measurement_unit:'percentage',
            success_threshold:'>=85', failure_threshold:'<=60',
            secondary_measurement:'errors_count', secondary_unit:'count', secondary_threshold:'<=1' },
          { drill_id:'DB06', drill_name:'Press Coverage', station_id:'DB', position_group:'DB', drill_type:'Rate',
            drill_category:'Competitive', primary_measurement:'win_rate', measurement_unit:'percentage',
            success_threshold:'>=60', failure_threshold:'<=30',
            secondary_measurement:'reps', secondary_unit:'count', secondary_threshold:'>=10' }
        ];
      }

      const sel = document.getElementById('dbDrillSel');
      sel.innerHTML = DB_DRILLS.map(d=>`<option value="${d.drill_id}">${d.drill_name}</option>`).join('');
      if (DB_DRILLS[0]) sel.value = DB_DRILLS[0].drill_id;
      sel.dispatchEvent(new Event('change'));
    }

    // Wire drill selection
    document.getElementById('dbDrillSel').addEventListener('change', ()=>{
      const sel = document.getElementById('dbDrillSel');
      DB_CURR = DB_DRILLS.find(x=>x.drill_id===sel.value) || null;
      const badge = document.getElementById('drillBadge');
      const hint  = document.getElementById('dbDrillHint');

      if (DB_CURR){
        badge.textContent = `Drill: ${DB_CURR.drill_name}`;
        const hintParts = [];
        if (DB_CURR.drill_category) hintParts.push(DB_CURR.drill_category);
        if (DB_CURR.success_threshold) hintParts.push(`Above Avg: ${DB_CURR.success_threshold}`);
        if (DB_CURR.failure_threshold) hintParts.push(`Below Avg: ${DB_CURR.failure_threshold}`);
        hint.textContent = hintParts.join(' • ');

        renderInputs('a', DB_CURR);
        renderInputs('b', DB_CURR);
        softResetLane('A'); softResetLane('B');
        document.getElementById('bothStartCard').style.display = isTimeDrill(DB_CURR) ? '' : 'none';
      } else {
        badge.textContent = 'Drill: —'; hint.textContent='';
      }
    });

    // ----- Recent writes (bottom) -----
    function addRecent(route, summary){
      pageLog.unshift({ ts:new Date(), route, summary });
      pageLog.splice(PAGE_LOG_LIMIT);
      const ul = qs('#recentList');
      const cnt = qs('#recentCount');
      ul.innerHTML = pageLog.map(it => `<li><strong>${fmtTime(it.ts)}</strong> — ${it.summary}</li>`).join('');
      cnt.textContent = pageLog.length ? `${pageLog.length} item${pageLog.length===1?'':'s'}` : '';
    }
    document.getElementById('toggleRecent').addEventListener('click', ()=>{
      const p = qs('#recentPanel');
      const open = p.style.display !== 'none';
      p.style.display = open ? 'none' : '';
      document.getElementById('toggleRecent').textContent = open ? 'Recent Writes ▾' : 'Recent Writes ▴';
    });

    /* -------- Saving indicator helpers -------- */
    function setSaving(lane, saving){
      const p = (lane==='A') ? 'a' : 'b';
      const saveBtn = document.getElementById(p+'Save');
      const toggleBtn = document.getElementById(p+'Toggle'); // may be hidden if non-time
      const resetBtn = document.getElementById(p+'Reset');   // may be hidden if non-time

      if (!saveBtn.dataset.label) saveBtn.dataset.label = saveBtn.textContent;

      if (saving){
        saveBtn.classList.add('loading');
        saveBtn.disabled = true;
        if (toggleBtn) toggleBtn.disabled = true;
        if (resetBtn)  resetBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spin"></span>Saving…';
      } else {
        saveBtn.classList.remove('loading');
        saveBtn.disabled = (lane==='A' ? !lanePlayers.A : !lanePlayers.B);
        if (toggleBtn) toggleBtn.disabled = false;
        if (resetBtn)  resetBtn.disabled  = false;
        saveBtn.textContent = saveBtn.dataset.label || 'Save';
      }
    }

    function readLaneValues(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      let primaryVal = null, secondaryVal = null, successes=0, failures=0, attempts=0;

      if (isTime){
        const timeEl = qs(`#${prefix}Time`);
        primaryVal = parseFloat((timeEl.textContent||'0').trim());
        if (isNaN(primaryVal)) primaryVal = null;

      } else if (isRate){
        const box = qs(`#${prefix}InputsBlock`);
        const succEl = box?.querySelector(`[data-counter-value="${prefix}Successes"]`);
        const failEl = box?.querySelector(`[data-counter-value="${prefix}Failures"]`);
        successes = parseInt(succEl?.textContent||'0');
        failures  = parseInt(failEl?.textContent||'0');
        attempts  = successes + failures;

        primaryVal = attempts>0 ? (successes/attempts)*100 : 0;

        // Secondary logic:
        // - if "attempts" or "reps": store attempts (goal-only; ignored in rating)
        // - if "errors_count": store failures (counts toward rating)
        const secName = String(drill.secondary_measurement||'').toLowerCase();
        if (/attempt|rep/.test(secName)) secondaryVal = attempts;
        else if (/errors_count/.test(secName)) secondaryVal = failures;
        else if (drill.secondary_measurement) secondaryVal = failures;

      }
      return { primaryVal, secondaryVal, successes, failures, attempts, isTime, isRate };
    }

    function score5FromRating(r){ return r==='above'?5 : r==='average'?3 : 1; }

    async function saveAttempt({ lane }){
      const prefix   = lane==='A' ? 'a' : 'b';
      const statusEl = document.getElementById(lane==='A' ? 'aStatus' : 'bStatus');
      const attSel   = document.getElementById(lane==='A' ? 'aAttempt': 'bAttempt');
      const logTbody = document.getElementById(lane==='A' ? 'aLog'    : 'bLog');

      statusEl.textContent = '';

      const c = ctx();
      if(!c.tryout_id){ statusEl.textContent='Set a Tryout ID first.'; statusEl.className='status warn'; return; }
      if(!DB_CURR){ statusEl.textContent='Choose a drill.'; statusEl.className='status warn'; return; }

      const player = lanePlayers[lane];
      if(!(player?.tryout_num || player?.player_id)){
        statusEl.textContent=`Assign a player to Lane ${lane}.`;
        statusEl.className='status warn';
        return;
      }

      // ensure timer stopped before read
      const t = timers.get(prefix);
      if (t?.isRunning()) t.stop();

      const vals = readLaneValues(prefix, DB_CURR);
      const { primaryVal, secondaryVal, successes, failures, attempts, isTime, isRate } = vals;
      const attempt = Number(attSel.value||1);

      // Evaluate performance
      const evaluation = evaluateDrill(DB_CURR, primaryVal, secondaryVal);

      const row = {
        timestamp:   new Date().toISOString(),
        tryout_id:   c.tryout_id || '',
        period_code: c.period_code || '',
        tryout_num:  String(player.tryout_num || '').trim(),
        player_id:   String(player.player_id || '').trim(),
        group_code:  resolveGroupCode(player.player_id, '', player) || '',
        station_id:  STATION_ID,
        drill_id:    DB_CURR.drill_id,
        attempt:     attempt,

        primary_name:  DB_CURR.primary_measurement || (isRate ? 'rate' : 'time'),
        primary_unit:  DB_CURR.measurement_unit || (isRate ? 'percentage' : 'sec'),
        primary_value: primaryVal,
        primary_successes: isRate ? successes : null,
        primary_failures:  isRate ? failures  : null,
        primary_attempts:  isRate ? attempts  : null,

        secondary_name:  DB_CURR.secondary_measurement || '',
        secondary_unit:  DB_CURR.secondary_unit || '',
        secondary_value: secondaryVal,

        rating_tier: evaluation.rating,           // 'above' | 'average' | 'below'
        pass_flag:   evaluation.rating==='above'?1:0,
        score_5:     score5FromRating(evaluation.rating),

        notes:       (document.getElementById('sharedNotes').value||'').trim(),
        source_app:  'station-db',
        client_id:   (localStorage.getItem('client_id')||'web'),

        // mirrors for downstream sheets
        metric_1:    primaryVal,
        metric_2:    secondaryVal,

        // expose errors count when relevant (primary is clean/error rate OR secondary is errors_count)
        errors_count: (/clean|error_rate/i.test(String(DB_CURR.primary_measurement||'')) || /errors_count/i.test(String(DB_CURR.secondary_measurement||''))) ? failures : null
      };

      setSaving(lane, true);
      let res;
      try { res = await API.tryout.write.station(row); }
      finally { setSaving(lane, false); }

      if(!res?.ok){
        statusEl.textContent = res?.error || 'Save failed.';
        statusEl.className = 'status err';
        return;
      }

      // Add to lane log
      const primTxt = primaryVal==null ? '—' :
                      (isTime ? Number(primaryVal).toFixed(2)+' s' :
                      isRate ? Number(primaryVal).toFixed(1)+'%' : String(primaryVal));
      const secTxt  = DB_CURR.secondary_measurement ? (secondaryVal==null ? '—' : String(secondaryVal)) : '—';

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${DB_CURR.drill_name}</td>
        <td>${attempt}</td>
        <td>${primTxt}</td>
        <td>${secTxt}</td>
        <td><span class="${evaluation.ratingClass}">${evaluation.ratingText}</span></td>`;
      logTbody.prepend(tr);
      while(logTbody.children.length > 10) logTbody.removeChild(logTbody.lastChild);

      // Recent Writes
      const who = player.tryout_num || player.player_id || '—';
      addRecent('station', `Write → DB :: ${who} • ${DB_CURR.drill_name} • ${primTxt}${DB_CURR.secondary_measurement?` • ${secTxt}`:''} • ${evaluation.ratingText} (Att ${attempt})`);

      // Mark done in the shared UI
      if (AFTER_SAVE.markDone) {
        try { TryoutUI?.markDone?.(player.player_id || player.tryout_num); } catch {}
        try { window.dispatchEvent(new CustomEvent('tryoutui:done', { detail:{ player_id: player.player_id, tryout_num: player.tryout_num } })); } catch {}
      }

      // Increment attempt & soft reset inputs/timer
      const next = Math.min((attempt % 10) + 1, 10);
      attSel.value = String(next);
      softResetLane(lane);

      statusEl.textContent = `Saved ✔ • ${evaluation.ratingText}`;
      statusEl.className = evaluation.rating==='above' ? 'status ok' :
                           evaluation.rating==='below' ? 'status warn' : 'status avg';
    }

    // wire lanes
    function wireLane(prefix){
      const toggleBtn = document.getElementById(prefix+'Toggle');
      const timeEl = document.getElementById(prefix+'Time');
      const statusEl = document.getElementById(prefix+'Status');

      const t = makeTimer(timeEl, (running)=>{
        if (toggleBtn){
          toggleBtn.textContent = running ? 'Stop' : 'Start';
          toggleBtn.setAttribute('aria-pressed', running ? 'true' : 'false');
          toggleBtn.classList.toggle('warn', running);
        }
        if (!running) statusEl.textContent = '';
      });
      timers.set(prefix, t);

      if (toggleBtn) toggleBtn.addEventListener('click', t.toggle);
      const resetBtn = document.getElementById(prefix+'Reset');
      if (resetBtn) resetBtn.addEventListener('click', ()=>{ softResetLane(prefix==='a'?'A':'B'); });
      document.getElementById(prefix+'Save').addEventListener('click', ()=>{ saveAttempt({ lane: (prefix==='a'?'A':'B') }); });
    }

    // Start both timers (time drills only)
    function wireBothStart(){
      const a = () => timers.get('a');
      const b = () => timers.get('b');
      const btn = document.getElementById('bothStart');
      if (!btn) return;
      btn.addEventListener('click', ()=>{ if(lanePlayers.A) a()?.start(); if(lanePlayers.B) b()?.start(); });
    }

    // Init
    (async function init(){
      wireLane('a');
      wireLane('b');
      wireBothStart();
      setActiveLane('A');

      await Promise.all([ loadRoster(), loadLatestGroups(), loadDBDrills() ]);

      // Preload selected player from TryoutUI if present
      if (window.TryoutUI?.getSelectedPlayers) {
        const cur = TryoutUI.getSelectedPlayers();
        if (Array.isArray(cur) && cur[0]) assignToActiveLane(cur[0]);
      }

      renderLaneChips();
    })();
  </script>
</body>
</html>
