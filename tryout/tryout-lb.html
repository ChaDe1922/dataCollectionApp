<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="gsds-api-base" content="https://script.google.com/macros/s/AKfycbw8Jb7RpQ7j9L2q32YDSBuNSPLFMjPzKdvuI_BgkutfNk5COrEYUdsUWZYXDOJRAeH3kA/exec">
  <title>LB Station — Tryouts</title>

  <!-- Simple auth guard -->
  <script>
    (function(){
      const ok = localStorage.getItem('auth_ok')==='1' &&
                 Number(localStorage.getItem('auth_until')||0) > Date.now();
      if(!ok){ window.location.href = '../index.html#login'; }
    })();
  </script>

  <!-- Theme + fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css"/>

  <style>
    .container{ max-width:1100px; margin:0 auto; padding:16px; }
    .grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    @media (max-width:900px){ .grid-2{ grid-template-columns:1fr; } }

    .card{ background: rgba(255,255,255,.05); border:1px solid var(--border);
           border-radius:16px; padding:16px; box-shadow: var(--shadow-soft, 0 8px 24px rgba(0,0,0,.18)); }
    .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
           border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); font-weight:700; }
    .chip.badge{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .chip.ghost{ background:transparent; }

    .assign{ display:flex; align-items:center; gap:8px; margin-left:auto; }
    .seg{ display:inline-flex; background:rgba(255,255,255,.06); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    .seg button{ appearance:none; border:0; padding:6px 10px; font-weight:800; color:#fff; background:transparent; cursor:pointer; }
    .seg button[aria-pressed="true"]{ background:#8B5CF6; color:#071018; }

    .field{ margin:10px 0; }
    .label{ font-weight:800; font-size:.95rem; opacity:.9; margin-bottom:6px; display:block; }
    .form-input, .form-select, .form-number{ width:100%; padding:.68rem .8rem; border-radius:12px; border:1px solid rgba(255,255,255,.28);
      background:rgba(255,255,255,.08); color:#fff; }
    .row{ display:grid; grid-template-columns: repeat(2, 1fr); gap:12px; }
    .row3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }

    .timer{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .time{ font-variant-numeric:tabular-nums; font-weight:900; font-size:1.25rem; min-width:82px; text-align:right; }

    .btn{ appearance:none; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:#fff;
          padding:.55rem .8rem; border-radius:10px; font-weight:800; cursor:pointer; transition: all .2s ease; }
    .btn.primary{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .btn.success{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; border:0; }
    .btn.warn{ background:linear-gradient(135deg,#F59E0B,#F59E0B); color:#2A1400; border:0; }
    .btn.ghost{ background:transparent; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    /* Counter control */
    .counter-control { display:flex; align-items:center; gap:8px; }
    .counter-btn {
      width:40px; height:40px; display:flex; align-items:center; justify-content:center;
      border-radius:8px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08);
      color:#fff; font-size:20px; font-weight:800; cursor:pointer; transition:all .2s ease; user-select:none;
    }
    .counter-btn:hover{ background:rgba(255,255,255,.15); transform:scale(1.05); }
    .counter-btn:active{ transform:scale(0.95); }
    .counter-value{ min-width:60px; text-align:center; font-size:24px; font-weight:900; color:#C4B5FD; font-variant-numeric:tabular-nums; }

    /* Toggle switch for boolean inputs */
    .toggle-switch{ display:inline-flex; align-items:center; gap:10px; cursor:pointer; user-select:none; }
    .toggle-switch input[type="checkbox"]{ position:absolute; opacity:0; width:0; height:0; }
    .toggle-slider{ position:relative; width:50px; height:26px; background:rgba(255,255,255,.15); border-radius:999px; transition:all .3s ease; border:1px solid rgba(255,255,255,.25); }
    .toggle-slider::before{ content:''; position:absolute; width:20px; height:20px; border-radius:50%; background:#fff; top:2px; left:3px; transition:all .3s ease; box-shadow:0 2px 4px rgba(0,0,0,.2); }
    .toggle-switch input:checked + .toggle-slider{ background:linear-gradient(135deg,#16A34A,#10B981); border-color:#16A34A; }
    .toggle-switch input:checked + .toggle-slider::before{ transform:translateX(23px); }
    .toggle-label{ font-weight:700; font-size:.9rem; }

    /* Save indicator */
    .btn.loading{ position:relative; pointer-events:none; }
    .btn.loading .spin{ width:14px; height:14px; border:2px solid rgba(255,255,255,.45);
                        border-top-color:#fff; border-radius:50%; display:inline-block;
                        margin-right:8px; vertical-align:-2px; animation:spin .8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .lane-title{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:900; letter-spacing:.04em; opacity:.9; }
    .lane-chip{ display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px;
                border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); font-weight:800; font-size:.9rem; }
    .lane-chip .x{ opacity:.7; cursor:pointer; padding:0 .25rem; }

    .lane-card{ transition: box-shadow .15s ease, border-color .15s ease; }
    .lane-card.lane-active{ border-color:#8B5CF6; box-shadow:0 0 0 2px rgba(139,92,246,.35) inset; }

    .small{ font-size:.85rem; opacity:.8; }
    .status{ margin-top:8px; font-weight:700; }
    .status.ok{ color:#34D399; } .status.err{ color:#F87171; } .status.warn{ color:#F59E0B; } .status.avg{ color:#8B5CF6; }

    .table{ width:100%; border-collapse:collapse; font-size:.95rem; }
    .table th,.table td{ padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12); text-align:left; }

    .muted{ opacity:.75; }
    .tu-log{ display:none !important; }

    /* Rating badges */
    .rating-above{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-avg{ background:linear-gradient(135deg,#8B5CF6,#A78BFA); color:#071018; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-below{ background:linear-gradient(135deg,#DC2626,#EF4444); color:#fff; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }

    .measure-help{ font-size:11px; opacity:.7; font-weight:500; margin-top:2px; font-style:italic; }
  </style>
</head>

<body class="theme-atl practice-page">
  <header class="page-header">
    <h1>LB Station</h1>
    <nav class="menu-actions">
      <a class="menu-btn" href="../index.html">Home</a>
      <a class="menu-btn" href="../tryout/index.html">Tryout Hub</a>
    </nav>
  </header>

  <main>
    <div class="container">
      <!-- Shared: context bar, filter chips, roster chips (filter to LB) -->
      <div id="tryout-shared" style="margin-bottom:12px"></div>

      <!-- Top control bar -->
      <section class="card" style="margin-bottom:14px">
        <div class="toolbar">
          <span class="chip">Station: <strong>LB</strong></span>

          <!-- Drill dropdown from Drill Dictionary -->
          <div class="field" style="min-width:280px; margin:0;">
            <label class="label">LB Drill</label>
            <select id="lbDrillSel" class="form-select"></select>
            <div id="lbDrillHint" class="small muted" style="margin-top:6px"></div>
          </div>

          <span id="drillBadge" class="chip badge">Drill: —</span>

          <!-- Assign selection to lane -->
          <div class="assign" style="margin-left:auto">
            <span class="chip ghost small">Assign selection to:</span>
            <div class="seg" role="tablist" aria-label="Active lane">
              <button id="segA" role="tab" aria-pressed="true">Lane A</button>
              <button id="segB" role="tab" aria-pressed="false">Lane B</button>
            </div>
          </div>
        </div>

        <!-- Picker + shared notes -->
        <div class="row" style="margin-top:10px">
          <div>
            <label class="label">Player (search by number or name)</label>
            <input id="playerPicker" class="form-input" list="lb_roster" placeholder="e.g., 52 • Mason Lee"/>
            <datalist id="lb_roster"></datalist>
          </div>
          <div>
            <label class="label">Notes (optional, applies to next save)</label>
            <input id="sharedNotes" class="form-input" placeholder="hash/side, gap fit, coverage drop, etc."/>
          </div>
        </div>

        <!-- Current lane assignments -->
        <div class="toolbar" style="margin-top:10px;gap:12px">
          <span id="chipLaneA" class="lane-chip" style="display:none"></span>
          <span id="chipLaneB" class="lane-chip" style="display:none"></span>
          <span class="small muted">Tip: time drills show timers; rate drills use success/failure and auto-calc attempts; attempts goal isn’t part of rating.</span>
        </div>
      </section>

      <!-- Two lanes -->
      <section class="grid-2">
        <!-- LANE A -->
        <div id="laneA" class="card lane-card lane-active">
          <div class="lane-title">
            <span>Lane A</span>
            <span id="laneAWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="row3 field">
            <div>
              <label class="label">Attempt</label>
              <select id="aAttempt" class="form-select">
                <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
                <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
              </select>
            </div>
            <div>
              <label class="label">Extra 1 (opt)</label>
              <input id="aExtra1" class="form-input" placeholder="gap/match, pursuit angle, etc."/>
            </div>
            <div>
              <label class="label">Extra 2 (opt)</label>
              <input id="aExtra2" class="form-input" placeholder="tags, footing, notes, etc."/>
            </div>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="aTimerBlock">
              <label class="label">Primary: <span id="aPrimaryLabel">Time</span></label>
              <div class="measure-help" id="aPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="aTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="aToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="aReset">Reset</button>
              </div>
            </div>
            <div id="aInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="aSave" disabled>Save Attempt (A)</button>
            </div>
          </div>

          <div class="status" id="aStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="aHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="aLog"></tbody>
          </table>
        </div>

        <!-- LANE B -->
        <div id="laneB" class="card lane-card">
          <div class="lane-title">
            <span>Lane B</span>
            <span id="laneBWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="row3 field">
            <div>
              <label class="label">Attempt</label>
              <select id="bAttempt" class="form-select">
                <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
                <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
              </select>
            </div>
            <div>
              <label class="label">Extra 1 (opt)</label>
              <input id="bExtra1" class="form-input" placeholder="gap/match, pursuit angle, etc."/>
            </div>
            <div>
              <label class="label">Extra 2 (opt)</label>
              <input id="bExtra2" class="form-input" placeholder="tags, footing, notes, etc."/>
            </div>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="bTimerBlock">
              <label class="label">Primary: <span id="bPrimaryLabel">Time</span></label>
              <div class="measure-help" id="bPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="bTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="bToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="bReset">Reset</button>
              </div>
            </div>
            <div id="bInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="bSave" disabled>Save Attempt (B)</button>
            </div>
          </div>

          <div class="status" id="bStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="bHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="bLog"></tbody>
          </table>
        </div>
      </section>

      <!-- Start both (below lanes, above writes) -->
      <section id="bothStartCard" class="card" style="margin-top:8px; display:none">
        <div class="toolbar" style="justify-content:center">
          <button id="bothStart" class="btn primary">Start Both</button>
        </div>
      </section>

      <!-- Recent writes (bottom) -->
      <section class="card" style="margin-top:14px">
        <div class="toolbar">
          <button id="toggleRecent" class="btn ghost">Recent Writes ▾</button>
          <span id="recentCount" class="small muted"></span>
        </div>
        <div id="recentPanel" style="display:none; margin-top:8px">
          <ul id="recentList" style="margin:0; padding-left:18px"></ul>
        </div>
      </section>
    </div>
  </main>

  <footer class="site-footer"><p>&copy; 2025 Game Speed Data Systems</p></footer>

  <!-- libs -->
  <script src="../js/api.js"></script>
  <script src="../js/rules.js"></script>
  <script src="../js/context.js"></script>
  <script src="../js/tryout-ui.js"></script>

  <script>
    // ---------- Boot shared context/UI ----------
    (function(){
      const meta = document.querySelector('meta[name="gsds-api-base"]');
      window.API_BASE = (meta && meta.content || '').trim();
    })();
    GameContext.configure({ apiBase: window.API_BASE, server: true, pollMs: 1000 });

    // LB group filter in the shared Tryout UI
    TryoutUI.init('#tryout-shared', { showGroup:true, filterMode:'groups', allowPresence:false });
    GameContext.setGroup('LB');

    // ---------- LB Station logic (dictionary-driven) ----------
    const STATION_ID = 'LB';
    const AFTER_SAVE = { clearLane:false, markDone:true };

    let roster = [];
    const groupLatest = new Map();
    const pageLog = [];
    const PAGE_LOG_LIMIT = 12;

    const lanePlayers = { A:null, B:null };
    let activeLane = 'A';
    const timers = new Map();
    let LB_DRILLS = [], LB_CURR = null;

    // ------- helpers -------
    const qs  = (s,p=document)=>p.querySelector(s);
    const qsa = (s,p=document)=>[...p.querySelectorAll(s)];
    const labelFor = (r)=> [r.tryout_num, '•', r.display_name, r.primary_pos?`(${r.primary_pos})`:'' ].filter(Boolean).join(' ');
    function ctx(){ return GameContext.get ? GameContext.get() : {}; }
    const fmtTime = (d)=>{ const pad=n=>String(n).padStart(2,'0'); return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };
    const isTimeDrill = d => /sec/i.test(String(d?.measurement_unit||''));
    const isRateDrill = d => /percentage|percent|rate/i.test(String(d?.measurement_unit||'')) || String(d?.drill_type||'').toUpperCase()==='RATE';

    // ------ Threshold parsing and evaluation (3-tier system) ------
    function parseThreshold(str) {
      if (!str) return null;
      const s = String(str).trim();
      if (/^(yes|true)$/i.test(s)) return { type: 'bool', value: true };
      if (/^(no|false)$/i.test(s)) return { type: 'bool', value: false };

      const rangeMatch = s.match(/^(-?\d+(?:\.\d+)?)\s*[-–]\s*(-?\d+(?:\.\d+)?)$/);
      if (rangeMatch) return { type: 'range', min: parseFloat(rangeMatch[1]), max: parseFloat(rangeMatch[2]) };

      const compMatch = s.match(/^(<=|>=|<|>|=|≤|≥)\s*(-?\d+(?:\.\d+)?)$/);
      if (compMatch) {
        const op = compMatch[1].replace('≤','<=').replace('≥','>=');
        return { type:'comp', op, value: parseFloat(compMatch[2]) };
      }

      if (!isNaN(parseFloat(s))) return { type:'comp', op:'>=', value: parseFloat(s) };
      return null;
    }

    function meetsThreshold(threshold, value) {
      if (!threshold || value == null) return null;
      if (threshold.type === 'bool') return !!value === threshold.value;
      if (threshold.type === 'range') return value >= threshold.min && value <= threshold.max;
      if (threshold.type === 'comp') {
        switch(threshold.op){
          case '<=': return value <= threshold.value;
          case '>=': return value >= threshold.value;
          case '<':  return value <  threshold.value;
          case '>':  return value >  threshold.value;
          case '=':  return value === threshold.value;
        }
      }
      return null;
    }

    function evaluateDrill(drill, primaryVal, secondaryVal){
      // Prefer centralized Rules if available
      try{
        if (window.Rules?.evaluateRep){
          const res = Rules.evaluateRep(drill, primaryVal, secondaryVal);
          if (res && typeof res.is_success==='boolean'){
            return {
              rating: res.is_success ? 'above' : (res.is_failure ? 'below' : 'average'),
              ratingText: res.is_success ? 'Above Average' : (res.is_failure ? 'Below Average' : 'Average'),
              ratingClass: res.is_success ? 'rating-above' : (res.is_failure ? 'rating-below' : 'rating-avg')
            };
          }
        }
      }catch(_){}

      // Fallback local evaluator using thresholds on primary + optional secondary
      const primaryOk   = meetsThreshold(parseThreshold(drill.success_threshold), primaryVal);
      const primaryFail = meetsThreshold(parseThreshold(drill.failure_threshold), primaryVal);

      // If it's a rate drill and secondary is "attempts", treat as goal only (not part of rating)
      const ignoreSecondaryForRating = isRateDrill(drill) && /attempt/i.test(String(drill.secondary_measurement||''));
      const secT  = ignoreSecondaryForRating ? null : parseThreshold(drill.secondary_threshold);
      const secOk = secT ? meetsThreshold(secT, secondaryVal) : true;

      if (primaryOk && secOk) return { rating:'above', ratingText:'Above Average',  ratingClass:'rating-above' };
      if (primaryFail || !secOk) return { rating:'below',  ratingText:'Below Average', ratingClass:'rating-below' };
      return { rating:'average', ratingText:'Average', ratingClass:'rating-avg' };
    }

    function normalizeValue(unit, raw){
      if (raw === '' || raw == null) return null;
      if (typeof raw === 'boolean') return raw;
      const u = String(unit||'').toLowerCase();
      if (u.includes('bool') || u==='boolean'){
        if (typeof raw === 'string') return /^(yes|true|1)$/i.test(raw.trim());
        return !!raw;
      }
      const n = parseFloat(raw);
      if (!isNaN(n)) return n;
      return raw;
    }

    // timers
    function makeTimer(timeEl, onState){
      let running=false, t0=0, acc=0, raf=null;
      const fmt = ms => (ms/1000).toFixed(2);
      const tick = ()=>{ const now=performance.now(); const ms=acc + (running ? (now-t0) : 0); timeEl.textContent = fmt(ms); if(running) raf=requestAnimationFrame(tick); };
      const start = ()=>{ if(running) return; running=true; t0=performance.now(); tick(); onState?.(true); };
      const stop  = ()=>{ if(!running) return; running=false; acc += performance.now()-t0; cancelAnimationFrame(raf); tick(); onState?.(false); };
      const reset = ()=>{ running=false; acc=0; cancelAnimationFrame(raf); tick(); onState?.(false); };
      const toggle= ()=> running ? stop() : start();
      tick();
      return { start, stop, reset, toggle, isRunning:()=>running };
    }

    // roster datalist
    async function loadRoster(){
      const res = await API.tryout.read.roster();
      if(!res?.ok) return;
      const tid = ctx().tryout_id || '';
      roster = (res.roster||[]).filter(r => !tid || String(r.tryout_id||'')===String(tid));
      const dl = document.getElementById('lb_roster');
      dl.innerHTML = '';
      roster.forEach(r=>{
        const rec = {
          player_id: r.player_id || '',
          display_name: r.display_name || r.player_name || '',
          primary_pos: r.primary_pos || r.position || '',
          tryout_num: r.tryout_num || r.jersey_number || '',
          group_code: r.group_code || r.primary_pos || ''
        };
        const opt = document.createElement('option');
        opt.value = labelFor(rec);
        opt.dataset.pid = rec.player_id;
        dl.appendChild(opt);
      });
    }

    async function loadLatestGroups(){
      const res = await API.tryout.read.groupsLatest(ctx().tryout_id);
      if(!res?.ok || !Array.isArray(res.latest)) return;
      groupLatest.clear();
      res.latest.forEach(row => { if(row.player_id && row.group_code) groupLatest.set(String(row.player_id).trim(), String(row.group_code).trim()); });
    }
    function resolveGroupCode(pid, fallback, rec){
      if (pid) {
        const direct = groupLatest.get(String(pid).trim());
        if (direct) return direct;
        const r = roster.find(x => String(x.player_id).trim() === String(pid).trim());
        return r?.group_code || r?.primary_pos || fallback || '';
      }
      return rec?.group_code || rec?.primary_pos || fallback || '';
    }

    // Active lane highlight
    function setActiveLane(l){
      activeLane = (l==='B') ? 'B' : 'A';
      document.getElementById('segA').setAttribute('aria-pressed', activeLane==='A' ? 'true':'false');
      document.getElementById('segB').setAttribute('aria-pressed', activeLane==='B' ? 'true':'false');
      qs('#laneA').classList.toggle('lane-active', activeLane==='A');
      qs('#laneB').classList.toggle('lane-active', activeLane==='B');
    }
    document.getElementById('segA').addEventListener('click', ()=> setActiveLane('A'));
    document.getElementById('segB').addEventListener('click', ()=> setActiveLane('B'));
    qs('#laneA').addEventListener('click', ()=> setActiveLane('A'));
    qs('#laneB').addEventListener('click', ()=> setActiveLane('B'));

    // Resets
    function softResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Time`).textContent = '0.00';
      const t = timers.get(p); t && t.reset();

      // clear dynamic inputs
      const box = qs(`#${p}InputsBlock`);
      if (box){
        box.querySelectorAll('[data-counter-value]').forEach(el=> el.textContent='0');
        box.querySelectorAll('input[type="checkbox"]').forEach(el=> el.checked=false);
      }
      qs(`#${p}Status`).textContent = '';
    }
    function hardResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Attempt`).value = '1';
      qs(`#${p}Log`).innerHTML = '';
      qs(`#${p}Extra1`).value = '';
      qs(`#${p}Extra2`).value = '';
      softResetLane(lane);
    }

    function renderLaneChips(){
      const a = lanePlayers.A, b = lanePlayers.B;
      const aEl = document.getElementById('laneAWho');
      const bEl = document.getElementById('laneBWho');
      const topA= document.getElementById('chipLaneA');
      const topB= document.getElementById('chipLaneB');

      if(a){
        const txt = `${a.tryout_num||''} • ${a.display_name||a.player_id}${a.primary_pos?` (${a.primary_pos})`:''}`;
        aEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="A">✕</span>`;
        aEl.style.display = '';
        topA.textContent = `Lane A: ${txt}`; topA.style.display = '';
        document.getElementById('aSave').disabled = false;
      } else {
        aEl.style.display = 'none'; topA.style.display = 'none';
        document.getElementById('aSave').disabled = true;
      }
      if(b){
        const txt = `${b.tryout_num||''} • ${b.display_name||b.player_id}${b.primary_pos?` (${b.primary_pos})`:''}`;
        bEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="B">✕</span>`;
        bEl.style.display = '';
        topB.textContent = `Lane B: ${txt}`; topB.style.display = '';
        document.getElementById('bSave').disabled = false;
      } else {
        bEl.style.display = 'none'; topB.style.display = 'none';
        document.getElementById('bSave').disabled = true;
      }

      document.querySelectorAll('[data-clear="A"]').forEach(x=> x.onclick = ()=>{ lanePlayers.A = null; renderLaneChips(); hardResetLane('A'); });
      document.querySelectorAll('[data-clear="B"]').forEach(x=> x.onclick = ()=>{ lanePlayers.B = null; renderLaneChips(); hardResetLane('B'); });
    }

    // Assign to active lane
    function assignToActiveLane(rec){
      lanePlayers[activeLane] = rec;
      document.getElementById('playerPicker').value = labelFor(rec);
      renderLaneChips();
      hardResetLane(activeLane);
    }

    // Selection sources
    window.addEventListener('tryoutui:select', (e)=>{
      const d = e?.detail?.player; if(!d) return;
      const hit = roster.find(r => r.player_id===d.player_id) || d;
      assignToActiveLane(hit);
    });
    document.getElementById('playerPicker').addEventListener('change', (e)=>{
      const txt = (e.target.value||'').toLowerCase();
      const hit = roster.find(r => labelFor(r).toLowerCase() === txt) ||
                  roster.find(r => String(r.tryout_num||'').toLowerCase() === txt) ||
                  roster.find(r => String(r.display_name||'').toLowerCase() === txt);
      if(hit) assignToActiveLane(hit);
    });

    // ---- Drill Dictionary hookup ----
    function renderInputs(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      const timerBlk = qs(`#${prefix}TimerBlock`);
      const inputBlk = qs(`#${prefix}InputsBlock`);
      const bothCard = qs('#bothStartCard');
      const primaryLabel = qs(`#${prefix}PrimaryLabel`);
      const primaryHelp = qs(`#${prefix}PrimaryHelp`);

      // Update primary label/help
      primaryLabel.textContent = isRate ? `${drill.primary_measurement} (calculated %)` : (drill.primary_measurement || 'Time');
      const parts = [];
      if (drill.drill_category) parts.push(drill.drill_category);
      if (drill.success_threshold) parts.push(`Above Avg: ${drill.success_threshold}`);
      if (drill.failure_threshold) parts.push(`Below Avg: ${drill.failure_threshold}`);
      primaryHelp.textContent = parts.join(' • ');

      // Toggle timer vs inputs
      timerBlk.style.display = isTime ? '' : 'none';
      inputBlk.style.display = isTime ? 'none' : '';

      // Update table head
      const head = qs(`#${prefix}Head`);
      head.innerHTML = `<tr>
        <th>Drill</th><th>Att</th>
        <th>${drill.primary_measurement || 'Primary'}</th>
        <th>${drill.secondary_measurement || 'Secondary'}</th>
        <th>Rating</th>
      </tr>`;

      // Start Both only for time drills
      bothCard.style.display = isTime ? '' : 'none';

      // Build inputs if not time
      inputBlk.innerHTML = '';
      if (!isTime){
        if (isRate){
          const succId = `${prefix}Successes`;
          const failId = `${prefix}Failures`;

          // Label mapping for LB context
          let successLabel = 'Successes';
          let failureLabel = 'Failures';
          const pmLower = String(drill.primary_measurement||'').toLowerCase();
          if (pmLower.includes('tackle')) { successLabel='Makes'; failureLabel='Misses'; }
          else if (pmLower.includes('win')) { successLabel='Wins'; failureLabel='Losses'; }
          else if (pmLower.includes('error')) { successLabel='Clean reps'; failureLabel='Errors'; }
          else if (pmLower.includes('pbu') || pmLower.includes('breakup')) { successLabel='PBUs'; failureLabel='Targets missed'; }

          // If secondary is "attempts" with a threshold, treat it as a goal chip (not part of rating)
          const attemptsIsGoal = /attempt/i.test(String(drill.secondary_measurement||'')) && drill.secondary_threshold;
          const secT = attemptsIsGoal ? parseThreshold(drill.secondary_threshold) : null;
          const goalValue = (secT && secT.type==='comp') ? secT.value : null;

          inputBlk.innerHTML = `
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
              <div>
                <label class="label">${successLabel}</label>
                <div class="counter-control">
                  <button class="counter-btn" data-counter-dec="${succId}" type="button">−</button>
                  <div class="counter-value" data-counter-value="${succId}">0</div>
                  <button class="counter-btn" data-counter-inc="${succId}" type="button">+</button>
                </div>
              </div>
              <div>
                <label class="label">${failureLabel}</label>
                <div class="counter-control">
                  <button class="counter-btn" data-counter-dec="${failId}" type="button">−</button>
                  <div class="counter-value" data-counter-value="${failId}">0</div>
                  <button class="counter-btn" data-counter-inc="${failId}" type="button">+</button>
                </div>
              </div>
            </div>

            <div class="small" style="margin-top:8px; display:flex; align-items:center; gap:10px;">
              <span>Attempts: <strong data-rate="${prefix}-att">0</strong></span>
              <span>• <strong data-rate="${prefix}-label">Success rate</strong>: <strong data-rate="${prefix}-pct">0.0%</strong></span>
              <span data-rate="${prefix}-goal" class="chip ghost small" style="display:${attemptsIsGoal?'inline-flex':'none'}"></span>
            </div>
          `;

          const update = ()=>{
            const s = parseInt(inputBlk.querySelector(`[data-counter-value="${succId}"]`)?.textContent||'0');
            const f = parseInt(inputBlk.querySelector(`[data-counter-value="${failId}"]`)?.textContent||'0');
            const att = s + f;

            const isErrorRate = pmLower.includes('error');
            const pct = att>0 ? (isErrorRate ? (f/att)*100 : (s/att)*100) : 0;

            inputBlk.querySelector(`[data-rate="${prefix}-att"]`).textContent = att;
            inputBlk.querySelector(`[data-rate="${prefix}-pct"]`).textContent = pct.toFixed(1)+'%';
            inputBlk.querySelector(`[data-rate="${prefix}-label"]`).textContent =
              isErrorRate ? 'Error rate' : (pmLower.includes('win') ? 'Win rate' :
              pmLower.includes('pbu')||pmLower.includes('breakup') ? 'Breakup rate' : 'Success rate');

            const goalEl = inputBlk.querySelector(`[data-rate="${prefix}-goal"]`);
            if (goalEl){
              if (goalValue!=null){
                const met = att >= goalValue;
                goalEl.textContent = met ? 'Goal met ✓' : `Goal ≥ ${goalValue} attempts`;
                goalEl.classList.toggle('badge', met);
              } else {
                goalEl.style.display = 'none';
              }
            }
          };
          inputBlk.querySelectorAll('[data-counter-inc],[data-counter-dec]').forEach(btn=>{
            const isInc = btn.hasAttribute('data-counter-inc');
            btn.addEventListener('click', ()=>{
              const id = btn.getAttribute(isInc ? 'data-counter-inc' : 'data-counter-dec');
              const el = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const cur = parseInt(el.textContent)||0;
              el.textContent = String(isInc ? cur+1 : Math.max(0,cur-1));
              update();
            });
          });

          // Override label/help for clarity
          primaryLabel.textContent =
            pmLower.includes('error') ? 'Error rate (calculated %)'
            : pmLower.includes('win') ? 'Win rate (calculated %)'
            : pmLower.includes('pbu') || pmLower.includes('breakup') ? 'Breakup rate (calculated %)'
            : 'Success rate (calculated %)';
          const parts2 = [];
          if (drill.drill_category) parts2.push(drill.drill_category);
          if (drill.success_threshold) parts2.push(`Above Avg: ${drill.success_threshold}`);
          if (drill.failure_threshold) parts2.push(`Below Avg: ${drill.failure_threshold}`);
          primaryHelp.textContent = parts2.join(' • ');
          update();

        } else {
          // Non-rate counters/toggles
          const makeCounter = (id, label, help='') => `
            <div>
              <label class="label">${label}</label>
              ${help ? `<div class="measure-help">${help}</div>` : ''}
              <div class="counter-control">
                <button class="counter-btn" data-counter-dec="${id}" type="button">−</button>
                <div class="counter-value" data-counter-value="${id}">0</div>
                <button class="counter-btn" data-counter-inc="${id}" type="button">+</button>
              </div>
            </div>`;
          const makeToggle = (id, label, help='') => `
            <div>
              <label class="label" style="margin-bottom:8px">${label}</label>
              ${help ? `<div class="measure-help" style="margin-bottom:6px">${help}</div>` : ''}
              <label class="toggle-switch">
                <input type="checkbox" id="${id}">
                <span class="toggle-slider"></span>
                <span class="toggle-label">Yes</span>
              </label>
            </div>`;

          const primId = `${prefix}PrimVal`;
          const secId  = `${prefix}SecVal`;
          const primIsBool = /bool/i.test(drill.measurement_unit||'') || (String(drill.measurement_unit||'').toLowerCase()==='boolean');
          const secIsBool  = /bool/i.test(drill.secondary_unit||'') || (String(drill.secondary_unit||'').toLowerCase()==='boolean');

          inputBlk.innerHTML += (primIsBool
            ? makeToggle(primId, drill.primary_measurement || 'Primary', drill.success_threshold?`Target: ${drill.success_threshold}`:'')
            : makeCounter(primId, drill.primary_measurement || 'Primary', drill.success_threshold?`Target: ${drill.success_threshold}`:''));

          if (drill.secondary_measurement){
            inputBlk.innerHTML += (secIsBool
              ? makeToggle(secId, drill.secondary_measurement, drill.secondary_threshold?`Target: ${drill.secondary_threshold}`:'')
              : makeCounter(secId, drill.secondary_measurement, drill.secondary_threshold?`Target: ${drill.secondary_threshold}`:''));
          }

          inputBlk.querySelectorAll('[data-counter-inc]').forEach(btn=>{
            btn.addEventListener('click', ()=>{
              const id = btn.getAttribute('data-counter-inc');
              const el = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              el.textContent = String((parseInt(el.textContent)||0)+1);
            });
          });
          inputBlk.querySelectorAll('[data-counter-dec]').forEach(btn=>{
            btn.addEventListener('click', ()=>{
              const id = btn.getAttribute('data-counter-dec');
              const el = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const cur = parseInt(el.textContent)||0;
              if (cur>0) el.textContent = String(cur-1);
            });
          });
        }
      }
    }

    async function loadLBDrills(){
      try {
        const res = await API.tryout.read.drills();
        if (res?.ok) {
          const all = res.drills || res.rows || [];
          LB_DRILLS = all.filter(d => {
            const pg = String(d.position_group || '').toUpperCase();
            const st = String(d.station_id || '').toUpperCase();
            return pg === 'LB' || st === 'LB' || st === 'LBS';
          });
        }
      } catch (e) { console.error('Error loading drills:', e); }

      // Fallback set if none returned (includes a rate drill with attempts goal)
      if (!Array.isArray(LB_DRILLS) || !LB_DRILLS.length){
        LB_DRILLS = [
          { drill_id:'LB01', drill_name:'Pursuit — 5-10-5 Shuttle', station_id:'LB', position_group:'LB', drill_type:'Time',
            drill_category:'Agility', primary_measurement:'time', measurement_unit:'sec',
            success_threshold:'<=4.50', failure_threshold:'>=5.40' },
          { drill_id:'LB02', drill_name:'Open Field Tackle — Make Rate', station_id:'LB', position_group:'LB', drill_type:'Rate',
            drill_category:'Tackling', primary_measurement:'tackle_make_rate', measurement_unit:'percentage',
            success_threshold:'>=70', failure_threshold:'<=50',
            secondary_measurement:'attempts', secondary_unit:'count', secondary_threshold:'>=10' },
          { drill_id:'LB03', drill_name:'Zone Drop & Break — Time', station_id:'LB', position_group:'LB', drill_type:'Time',
            drill_category:'Coverage', primary_measurement:'time', measurement_unit:'sec',
            success_threshold:'<=3.90', failure_threshold:'>=4.80' }
        ];
      }

      const sel = document.getElementById('lbDrillSel');
      sel.innerHTML = LB_DRILLS.map(d=>`<option value="${d.drill_id}">${d.drill_name}</option>`).join('');
      if (LB_DRILLS[0]) sel.value = LB_DRILLS[0].drill_id;
      sel.dispatchEvent(new Event('change'));
    }

    // Wire drill selection
    document.getElementById('lbDrillSel').addEventListener('change', ()=>{
      const sel = document.getElementById('lbDrillSel');
      LB_CURR = LB_DRILLS.find(x=>x.drill_id===sel.value) || null;
      const badge = document.getElementById('drillBadge');
      const hint  = document.getElementById('lbDrillHint');

      if (LB_CURR){
        badge.textContent = `Drill: ${LB_CURR.drill_name}`;
        const hintParts = [];
        if (LB_CURR.drill_category) hintParts.push(LB_CURR.drill_category);
        if (LB_CURR.success_threshold) hintParts.push(`Above Avg: ${LB_CURR.success_threshold}`);
        if (LB_CURR.failure_threshold) hintParts.push(`Below Avg: ${LB_CURR.failure_threshold}`);
        hint.textContent = hintParts.join(' • ');

        renderInputs('a', LB_CURR);
        renderInputs('b', LB_CURR);
        softResetLane('A'); softResetLane('B');
      } else {
        badge.textContent = 'Drill: —'; hint.textContent='';
      }
    });

    // ----- Recent writes (bottom) -----
    function addRecent(route, summary){
      pageLog.unshift({ ts:new Date(), route, summary });
      pageLog.splice(PAGE_LOG_LIMIT);
      renderRecent();
    }
    function renderRecent(){
      const ul = qs('#recentList');
      const cnt = qs('#recentCount');
      if (!ul) return;
      ul.innerHTML = pageLog.map(it => `<li><strong>${fmtTime(it.ts)}</strong> — ${it.summary}</li>`).join('');
      cnt.textContent = pageLog.length ? `${pageLog.length} item${pageLog.length===1?'':'s'}` : '';
    }
    qs('#toggleRecent').addEventListener('click', ()=>{
      const p = qs('#recentPanel');
      const open = p.style.display !== 'none';
      p.style.display = open ? 'none' : '';
      qs('#toggleRecent').textContent = open ? 'Recent Writes ▾' : 'Recent Writes ▴';
    });

    /* -------- Saving indicator helpers -------- */
    function setSaving(lane, saving){
      const p = (lane==='A') ? 'a' : 'b';
      const saveBtn = document.getElementById(p+'Save');
      const toggleBtn = document.getElementById(p+'Toggle'); // may be hidden if non-time
      const resetBtn = document.getElementById(p+'Reset');   // may be hidden if non-time

      if (!saveBtn.dataset.label) saveBtn.dataset.label = saveBtn.textContent;

      if (saving){
        saveBtn.classList.add('loading');
        saveBtn.disabled = true;
        if (toggleBtn) toggleBtn.disabled = true;
        if (resetBtn) toggleBtn && (resetBtn.disabled = true);
        saveBtn.innerHTML = '<span class="spin"></span>Saving…';
      } else {
        saveBtn.classList.remove('loading');
        saveBtn.disabled = (lane==='A' ? !lanePlayers.A : !lanePlayers.B);
        if (toggleBtn) toggleBtn.disabled = false;
        if (resetBtn)  resetBtn.disabled  = false;
        saveBtn.textContent = saveBtn.dataset.label || 'Save';
      }
    }

    function readLaneValues(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      let primaryVal = null, secondaryVal = null;

      if (isTime){
        const timeEl = qs(`#${prefix}Time`);
        primaryVal = parseFloat((timeEl.textContent||'0').trim());
        if (isNaN(primaryVal)) primaryVal = null;

      } else if (isRate){
        // successes / failures -> % ; attempts derived (stored if secondary is attempts)
        const box = qs(`#${prefix}InputsBlock`);
        const succEl = box?.querySelector(`[data-counter-value="${prefix}Successes"]`);
        const failEl = box?.querySelector(`[data-counter-value="${prefix}Failures"]`);
        const s = parseInt(succEl?.textContent||'0');
        const f = parseInt(failEl?.textContent||'0');
        const att = s + f;

        const pm = String(drill.primary_measurement||'').toLowerCase();
        const isErrorRate = pm.includes('error');

        primaryVal = att>0 ? (isErrorRate ? (f/att)*100 : (s/att)*100) : null;
        secondaryVal = /attempt/i.test(String(drill.secondary_measurement||'')) ? att : null;

      } else {
        const box = qs(`#${prefix}InputsBlock`);
        const primId = `${prefix}PrimVal`;
        const secId  = `${prefix}SecVal`;

        const primCounter = box?.querySelector(`[data-counter-value="${primId}"]`);
        const primToggle  = box?.querySelector(`#${primId}`);
        const secCounter  = box?.querySelector(`[data-counter-value="${secId}"]`);
        const secToggle   = box?.querySelector(`#${secId}`);

        if (primCounter) primaryVal = parseInt(primCounter.textContent)||0;
        else if (primToggle) primaryVal = primToggle.checked;

        if (secCounter) secondaryVal = parseInt(secCounter.textContent)||0;
        else if (secToggle) secondaryVal = secToggle.checked;

        primaryVal = normalizeValue(drill.measurement_unit, primaryVal);
        secondaryVal = (secondaryVal!=null) ? normalizeValue(drill.secondary_unit, secondaryVal) : null;
      }
      return { primaryVal, secondaryVal, isTime, isRate };
    }

    async function saveAttempt({ lane }){
      const prefix   = lane==='A' ? 'a' : 'b';
      const statusEl = document.getElementById(lane==='A' ? 'aStatus' : 'bStatus');
      const attSel   = document.getElementById(lane==='A' ? 'aAttempt': 'bAttempt');
      const logTbody = document.getElementById(lane==='A' ? 'aLog'    : 'bLog');

      statusEl.textContent = '';

      const c = ctx();
      if(!c.tryout_id){ statusEl.textContent='Set a Tryout ID first.'; statusEl.className='status warn'; return; }
      if(!LB_CURR){ statusEl.textContent='Choose a drill.'; statusEl.className='status warn'; return; }

      const player = lanePlayers[lane];
      if(!(player?.tryout_num || player?.player_id)){
        statusEl.textContent=`Assign a player to Lane ${lane}.`;
        statusEl.className='status warn';
        return;
      }

      // ensure timer stopped before read
      const t = timers.get(prefix);
      if (t?.isRunning()) t.stop();

      const { primaryVal, secondaryVal, isTime, isRate } = readLaneValues(prefix, LB_CURR);
      const attempt = Number(attSel.value||1);

      // Evaluate performance
      const evaluation = evaluateDrill(LB_CURR, primaryVal, secondaryVal);

      const row = {
        tryout_id:   c.tryout_id || '',
        period_code: c.period_code || '',
        tryout_num:  String(player.tryout_num || '').trim(),
        player_id:   String(player.player_id || '').trim(),
        group_code:  resolveGroupCode(player.player_id, '', player) || '',
        station_id:  STATION_ID,
        drill_id:    LB_CURR.drill_id,
        attempt:     attempt,
        metric_1:    (primaryVal===true)?1:(primaryVal===false)?0:primaryVal,
        metric_2:    (secondaryVal===true)?1:(secondaryVal===false)?0:secondaryVal,
        pass_flag:   evaluation.rating==='above' ? 1 : 0,
        notes:       (document.getElementById('sharedNotes').value||'').trim(),
        extra_1:     (document.getElementById(prefix+'Extra1').value||'').trim(),
        extra_2:     (document.getElementById(prefix+'Extra2').value||'').trim()
      };

      setSaving(lane, true);
      let res;
      try { res = await API.tryout.write.station(row); }
      finally { setSaving(lane, false); }

      if(!res?.ok){
        statusEl.textContent = res?.error || 'Save failed.';
        statusEl.className = 'status err';
        return;
      }

      // Add to lane log
      const primTxt = primaryVal==null ? '—' :
                      (isTime ? Number(primaryVal).toFixed(2)+' s' :
                      isRate ? Number(primaryVal).toFixed(1)+'%' : String(primaryVal));
      const secTxt  = LB_CURR.secondary_measurement ? (secondaryVal==null ? '—' : String(secondaryVal)) : '—';

      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${LB_CURR.drill_name}</td>
        <td>${attempt}</td>
        <td>${primTxt}</td>
        <td>${secTxt}</td>
        <td><span class="${evaluation.ratingClass}">${evaluation.ratingText}</span></td>`;
      logTbody.prepend(tr);
      while(logTbody.children.length > 10) logTbody.removeChild(logTbody.lastChild);

      // Recent Writes
      const who = player.tryout_num || player.player_id || '—';
      addRecent('station', `Write → LB :: ${who} • ${LB_CURR.drill_name} • ${primTxt}${LB_CURR.secondary_measurement?` • ${secTxt}`:''} • ${evaluation.ratingText} (Att ${attempt})`);

      // Mark done in the shared UI
      if (AFTER_SAVE.markDone) {
        try { TryoutUI?.markDone?.(player.player_id || player.tryout_num); } catch {}
        try { window.dispatchEvent(new CustomEvent('tryoutui:done', { detail:{ player_id: player.player_id, tryout_num: player.tryout_num } })); } catch {}
      }

      // Increment attempt & soft reset inputs/timer
      const next = Math.min((attempt % 10) + 1, 10);
      attSel.value = String(next);
      softResetLane(lane);

      statusEl.textContent = `Saved ✔ • ${evaluation.ratingText}`;
      statusEl.className = evaluation.rating==='above' ? 'status ok' :
                           evaluation.rating==='below' ? 'status warn' : 'status avg';
    }

    // wire lanes
    function wireLane(prefix){
      const toggleBtn = document.getElementById(prefix+'Toggle');
      const timeEl = document.getElementById(prefix+'Time');
      const statusEl = document.getElementById(prefix+'Status');

      const t = makeTimer(timeEl, (running)=>{
        if (toggleBtn){
          toggleBtn.textContent = running ? 'Stop' : 'Start';
          toggleBtn.setAttribute('aria-pressed', running ? 'true' : 'false');
          toggleBtn.classList.toggle('warn', running);
        }
        if (!running) statusEl.textContent = '';
      });
      timers.set(prefix, t);

      if (toggleBtn) toggleBtn.addEventListener('click', t.toggle);
      const resetBtn = document.getElementById(prefix+'Reset');
      if (resetBtn) resetBtn.addEventListener('click', ()=>{ softResetLane(prefix==='a'?'A':'B'); });
      document.getElementById(prefix+'Save').addEventListener('click', ()=>{ saveAttempt({ lane: (prefix==='a'?'A':'B') }); });
    }

    // Start both timers (time drills only)
    function wireBothStart(){
      const a = () => timers.get('a');
      const b = () => timers.get('b');
      const btn = document.getElementById('bothStart');
      if (!btn) return;
      btn.addEventListener('click', ()=>{ if(lanePlayers.A) a()?.start(); if(lanePlayers.B) b()?.start(); });
    }

    // Init
    (async function init(){
      wireLane('a');
      wireLane('b');
      wireBothStart();
      setActiveLane('A');

      await Promise.all([ loadRoster(), loadLatestGroups(), loadLBDrills() ]);

      // Preload selected player from TryoutUI if present
      if (window.TryoutUI?.getSelectedPlayers) {
        const cur = TryoutUI.getSelectedPlayers();
        if (Array.isArray(cur) && cur[0]) assignToActiveLane(cur[0]);
      }

      renderLaneChips();
    })();
  </script>
</body>
</html>
