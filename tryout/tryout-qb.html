<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="gsds-api-base" content="https://script.google.com/macros/s/AKfycbw8Jb7RpQ7j9L2q32YDSBuNSPLFMjPzKdvuI_BgkutfNk5COrEYUdsUWZYXDOJRAeH3kA/exec">
  <title>QB Station — Tryouts</title>

  <!-- Simple auth guard -->
  <script>
    (function(){
      const ok = localStorage.getItem('auth_ok')==='1' &&
                 Number(localStorage.getItem('auth_until')||0) > Date.now();
      if(!ok){ window.location.href = '../index.html#login'; }
    })();
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@300;400;600;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css"/>

  <style>
    .container{ max-width:1100px; margin:0 auto; padding:16px; }
    .grid-2{ display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    @media (max-width:900px){ .grid-2{ grid-template-columns:1fr; } }

    .card{ background: rgba(255,255,255,.05); border:1px solid var(--border);
           border-radius:16px; padding:16px; box-shadow: var(--shadow-soft, 0 8px 24px rgba(0,0,0,.18)); }
    .toolbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .chip{ display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
           border:1px solid rgba(255,255,255,.15); background:rgba(255,255,255,.06); font-weight:700; }
    .chip.badge{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .chip.ghost{ background:transparent; }

    .assign{ display:flex; align-items:center; gap:8px; margin-left:auto; }
    .seg{ display:inline-flex; background:rgba(255,255,255,.06); border:1px solid var(--border); border-radius:10px; overflow:hidden; }
    .seg button{ appearance:none; border:0; padding:6px 10px; font-weight:800; color:#fff; background:transparent; cursor:pointer; }
    .seg button[aria-pressed="true"]{ background:#8B5CF6; color:#071018; }

    .field{ margin:10px 0; }
    .label{ font-weight:800; font-size:.95rem; opacity:.9; margin-bottom:6px; display:block; }
    .form-input, .form-select, .form-number{ width:100%; padding:.68rem .8rem; border-radius:12px; border:1px solid rgba(255,255,255,.28);
      background:rgba(255,255,255,.08); color:#fff; }
    .row{ display:grid; grid-template-columns: repeat(2, 1fr); gap:12px; }
    .row3{ display:grid; grid-template-columns: 1fr 1fr 1fr; gap:12px; }

    .timer{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .time{ font-variant-numeric:tabular-nums; font-weight:900; font-size:1.25rem; min-width:82px; text-align:right; }

    .btn{ appearance:none; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); color:#fff;
          padding:.55rem .8rem; border-radius:10px; font-weight:800; cursor:pointer; transition: all .2s ease; }
    .btn.primary{ background:linear-gradient(135deg,#7C4DFF,#8B5CF6); color:#071018; border:0; }
    .btn.success{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; border:0; }
    .btn.warn{ background:linear-gradient(135deg,#F59E0B,#F59E0B); color:#2A1400; border:0; }
    .btn.ghost{ background:transparent; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    /* Counter control */
    .counter-control {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .counter-btn {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.08);
      color: #fff;
      font-size: 20px;
      font-weight: 800;
      cursor: pointer;
      transition: all .2s ease;
      user-select: none;
    }
    .counter-btn:hover {
      background: rgba(255,255,255,.15);
      transform: scale(1.05);
    }
    .counter-btn:active {
      transform: scale(0.95);
    }
    .counter-value {
      min-width: 60px;
      text-align: center;
      font-size: 24px;
      font-weight: 900;
      color: #C4B5FD;
      font-variant-numeric: tabular-nums;
    }

    /* Rate display (calculated percentage) */
    .rate-display {
      margin-top: 8px;
      padding: 8px 12px;
      background: rgba(139, 92, 246, 0.15);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 8px;
      text-align: center;
    }
    .rate-value {
      font-size: 28px;
      font-weight: 900;
      color: #C4B5FD;
      font-variant-numeric: tabular-nums;
    }
    .rate-label {
      font-size: 11px;
      opacity: 0.7;
      margin-top: 2px;
    }

    /* Toggle switch for boolean inputs */
    .toggle-switch {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      user-select: none;
    }
    .toggle-switch input[type="checkbox"] {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: relative;
      width: 50px;
      height: 26px;
      background: rgba(255,255,255,.15);
      border-radius: 999px;
      transition: all .3s ease;
      border: 1px solid rgba(255,255,255,.25);
    }
    .toggle-slider::before {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      top: 2px;
      left: 3px;
      transition: all .3s ease;
      box-shadow: 0 2px 4px rgba(0,0,0,.2);
    }
    .toggle-switch input:checked + .toggle-slider {
      background: linear-gradient(135deg,#16A34A,#10B981);
      border-color: #16A34A;
    }
    .toggle-switch input:checked + .toggle-slider::before {
      transform: translateX(23px);
    }
    .toggle-label {
      font-weight: 700;
      font-size: 0.9rem;
    }

    /* Save indicator */
    .btn.loading{ position:relative; pointer-events:none; }
    .btn.loading .spin{ width:14px; height:14px; border:2px solid rgba(255,255,255,.45);
                        border-top-color:#fff; border-radius:50%; display:inline-block;
                        margin-right:8px; vertical-align:-2px; animation:spin .8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    .lane-title{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:900; letter-spacing:.04em; opacity:.9; }
    .lane-chip{ display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px;
                border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.08); font-weight:800; font-size:.9rem; }
    .lane-chip .x{ opacity:.7; cursor:pointer; padding:0 .25rem; }

    .lane-card{ transition: box-shadow .15s ease, border-color .15s ease; }
    .lane-card.lane-active{ border-color:#8B5CF6; box-shadow:0 0 0 2px rgba(139,92,246,.35) inset; }

    .small{ font-size:.85rem; opacity:.8; }
    .status{ margin-top:8px; font-weight:700; }
    .status.ok{ color:#34D399; } 
    .status.err{ color:#F87171; } 
    .status.warn{ color:#F59E0B; }
    .status.avg{ color:#8B5CF6; }

    .table{ width:100%; border-collapse:collapse; font-size:.95rem; }
    .table th,.table td{ padding:6px 8px; border-bottom:1px solid rgba(255,255,255,.12); text-align:left; }

    .muted{ opacity:.75; }
    .tu-log{ display:none !important; }

    /* Rating badges */
    .rating-above{ background:linear-gradient(135deg,#16A34A,#10B981); color:#061710; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-avg{ background:linear-gradient(135deg,#8B5CF6,#A78BFA); color:#071018; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }
    .rating-below{ background:linear-gradient(135deg,#DC2626,#EF4444); color:#fff; padding:4px 8px; border-radius:6px; font-weight:800; font-size:11px; }

    /* Measurement help text */
    .measure-help {
      font-size: 11px;
      opacity: 0.7;
      font-weight: 500;
      margin-top: 2px;
      font-style: italic;
    }
  </style>
</head>

<body class="theme-atl practice-page">
  <header class="page-header">
    <h1>QB Station</h1>
    <nav class="menu-actions">
      <a class="menu-btn" href="../index.html">Home</a>
      <a class="menu-btn" href="../tryout/index.html">Tryout Hub</a>
    </nav>
  </header>

  <main>
    <div class="container">
      <!-- Shared: context bar, filter chips, roster chips (will filter by QB) -->
      <div id="tryout-shared" style="margin-bottom:12px"></div>

      <!-- Top control bar -->
      <section class="card" style="margin-bottom:14px">
        <div class="toolbar">
          <span class="chip">Station: <strong>QB</strong></span>

          <!-- Drill dropdown from Drill Dictionary -->
          <div class="field" style="min-width:280px; margin:0;">
            <label class="label">QB Drill</label>
            <select id="qbDrillSel" class="form-select"></select>
            <div id="qbDrillHint" class="small muted" style="margin-top:6px"></div>
          </div>

          <span id="drillBadge" class="chip badge">Drill: —</span>

          <!-- Assign selection to lane -->
          <div class="assign" style="margin-left:auto">
            <span class="chip ghost small">Assign selection to:</span>
            <div class="seg" role="tablist" aria-label="Active lane">
              <button id="segA" role="tab" aria-pressed="true">Lane A</button>
              <button id="segB" role="tab" aria-pressed="false">Lane B</button>
            </div>
          </div>
        </div>

        <!-- Picker + shared notes -->
        <div class="row" style="margin-top:10px">
          <div>
            <label class="label">Player (search by number or name)</label>
            <input id="playerPicker" class="form-input" list="qb_roster" placeholder="e.g., 12 • Jordan Price"/>
            <datalist id="qb_roster"></datalist>
          </div>
          <div>
            <label class="label">Notes (optional, applies to next save)</label>
            <input id="sharedNotes" class="form-input" placeholder="hash L, windy, wet ball, etc."/>
          </div>
        </div>

        <!-- Current lane assignments -->
        <div class="toolbar" style="margin-top:10px;gap:12px">
          <span id="chipLaneA" class="lane-chip" style="display:none"></span>
          <span id="chipLaneB" class="lane-chip" style="display:none"></span>
          <span class="small muted">Tip: attempts auto-increment after each save. Change player to reset.</span>
        </div>
      </section>

      <!-- Two lanes -->
      <section class="grid-2">
        <!-- LANE A -->
        <div id="laneA" class="card lane-card lane-active">
          <div class="lane-title">
            <span>Lane A</span>
            <span id="laneAWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="row3 field">
            <div>
              <label class="label">Attempt</label>
              <select id="aAttempt" class="form-select">
                <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
                <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
              </select>
            </div>
            <div>
              <label class="label">Extra 1 (opt)</label>
              <input id="aExtra1" class="form-input" placeholder="Velocity, target, etc."/>
            </div>
            <div>
              <label class="label">Extra 2 (opt)</label>
              <input id="aExtra2" class="form-input" placeholder="Tags, route, etc."/>
            </div>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="aTimerBlock">
              <label class="label">Primary: <span id="aPrimaryLabel">Time</span></label>
              <div class="measure-help" id="aPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="aTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="aToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="aReset">Reset</button>
              </div>
            </div>
            <div id="aInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="aSave" disabled>Save Attempt (A)</button>
            </div>
          </div>

          <div class="status" id="aStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="aHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="aLog"></tbody>
          </table>
        </div>

        <!-- LANE B -->
        <div id="laneB" class="card lane-card">
          <div class="lane-title">
            <span>Lane B</span>
            <span id="laneBWho" class="lane-chip" style="display:none"></span>
          </div>

          <div class="row3 field">
            <div>
              <label class="label">Attempt</label>
              <select id="bAttempt" class="form-select">
                <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
                <option>6</option><option>7</option><option>8</option><option>9</option><option>10</option>
              </select>
            </div>
            <div>
              <label class="label">Extra 1 (opt)</label>
              <input id="bExtra1" class="form-input" placeholder="Velocity, target, etc."/>
            </div>
            <div>
              <label class="label">Extra 2 (opt)</label>
              <input id="bExtra2" class="form-input" placeholder="Tags, route, etc."/>
            </div>
          </div>

          <!-- Dynamic primary/secondary -->
          <div class="field">
            <div id="bTimerBlock">
              <label class="label">Primary: <span id="bPrimaryLabel">Time</span></label>
              <div class="measure-help" id="bPrimaryHelp"></div>
              <div class="timer">
                <span class="time" id="bTime">0.00</span><span class="small muted">sec</span>
                <button class="btn" id="bToggle" aria-pressed="false">Start</button>
                <button class="btn ghost" id="bReset">Reset</button>
              </div>
            </div>
            <div id="bInputsBlock" style="display:none; margin-top:8px"></div>
            <div style="margin-top:8px">
              <button class="btn success" id="bSave" disabled>Save Attempt (B)</button>
            </div>
          </div>

          <div class="status" id="bStatus"></div>

          <table class="table" style="margin-top:10px">
            <thead id="bHead"><tr><th>Drill</th><th>Att</th><th>Primary</th><th>Secondary</th><th>Rating</th></tr></thead>
            <tbody id="bLog"></tbody>
          </table>
        </div>
      </section>

      <!-- Start both (below lanes, above writes) -->
      <section id="bothStartCard" class="card" style="margin-top:8px; display:none">
        <div class="toolbar" style="justify-content:center">
          <button id="bothStart" class="btn primary">Start Both</button>
        </div>
      </section>

      <!-- Recent writes (bottom) -->
      <section class="card" style="margin-top:14px">
        <div class="toolbar">
          <button id="toggleRecent" class="btn ghost">Recent Writes ▾</button>
          <span id="recentCount" class="small muted"></span>
        </div>
        <div id="recentPanel" style="display:none; margin-top:8px">
          <ul id="recentList" style="margin:0; padding-left:18px"></ul>
        </div>
      </section>

    </div>
  </main>

  <footer class="site-footer"><p>&copy; 2025 Game Speed Data Systems</p></footer>

  <!-- libs -->
  <script src="../js/api.js"></script>
  <script src="../js/rules.js"></script>
  <script src="../js/context.js"></script>
  <script src="../js/tryout-ui.js"></script>

  <script>
    // ---------- Boot shared context/UI ----------
    (function(){
      const meta = document.querySelector('meta[name="gsds-api-base"]');
      window.API_BASE = (meta && meta.content || '').trim();
    })();
    GameContext.configure({ apiBase: window.API_BASE, server: true, pollMs: 1000 });
    
    // Initialize with QB group filter
    TryoutUI.init('#tryout-shared', { 
      showGroup: true,
      filterMode: 'groups',
      allowPresence: false 
    });
    
    GameContext.setGroup('QB');

    // ---------- QB Station logic (dictionary-driven) ----------
    const STATION_ID = 'QB';
    const AFTER_SAVE = { clearLane:false, markDone:true };

    let roster = [];
    const groupLatest = new Map();
    const pageLog = [];
    const PAGE_LOG_LIMIT = 12;

    const lanePlayers = { A:null, B:null };
    let activeLane = 'A';
    const timers = new Map();
    let QB_DRILLS = [], QB_CURR = null;

    // ------- helpers -------
    const qs  = (s,p=document)=>p.querySelector(s);
    const qsa = (s,p=document)=>[...p.querySelectorAll(s)];
    const labelFor = (r)=> [r.tryout_num, '•', r.display_name, r.primary_pos?`(${r.primary_pos})`:'' ].filter(Boolean).join(' ');
    function ctx(){ return GameContext.get ? GameContext.get() : {}; }
    const fmtTime = (d)=>{ const pad=n=>String(n).padStart(2,'0'); return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; };
    const isTimeDrill = d => /sec/i.test(String(d?.measurement_unit||''));
    const isRateDrill = d => /percentage|percent|rate/i.test(String(d?.measurement_unit||'')) || String(d?.drill_type||'').toUpperCase() === 'RATE';

    // ------ Threshold parsing and evaluation (3-tier system) ------
    function parseThreshold(str) {
      if (!str) return null;
      const s = String(str).trim();
      
      if (/^(yes|true)$/i.test(s)) return { type: 'bool', value: true };
      if (/^(no|false)$/i.test(s)) return { type: 'bool', value: false };
      
      const rangeMatch = s.match(/^(-?\d+(?:\.\d+)?)\s*[-–]\s*(-?\d+(?:\.\d+)?)$/);
      if (rangeMatch) {
        return { type: 'range', min: parseFloat(rangeMatch[1]), max: parseFloat(rangeMatch[2]) };
      }
      
      const compMatch = s.match(/^(<=|>=|<|>|=|≤|≥)\s*(-?\d+(?:\.\d+)?)$/);
      if (compMatch) {
        const op = compMatch[1].replace('≤', '<=').replace('≥', '>=');
        return { type: 'comp', op, value: parseFloat(compMatch[2]) };
      }
      
      if (!isNaN(parseFloat(s))) {
        return { type: 'comp', op: '>=', value: parseFloat(s) };
      }
      
      return null;
    }

    function meetsThreshold(threshold, value) {
      if (!threshold || value == null) return null;
      
      if (threshold.type === 'bool') {
        return !!value === threshold.value;
      }
      
      if (threshold.type === 'range') {
        return value >= threshold.min && value <= threshold.max;
      }
      
      if (threshold.type === 'comp') {
        switch(threshold.op) {
          case '<=': return value <= threshold.value;
          case '>=': return value >= threshold.value;
          case '<': return value < threshold.value;
          case '>': return value > threshold.value;
          case '=': return value === threshold.value;
          default: return null;
        }
      }
      
      return null;
    }

    function evaluateDrill(drill, primaryVal, secondaryVal) {
      const successThresh = parseThreshold(drill.success_threshold);
      const failureThresh = parseThreshold(drill.failure_threshold);
      const secondaryThresh = parseThreshold(drill.secondary_threshold);
      
      const meetsSuccess = meetsThreshold(successThresh, primaryVal);
      const meetsFailure = meetsThreshold(failureThresh, primaryVal);
      
      let meetsSecondary = true;
      if (secondaryThresh && secondaryVal != null) {
        meetsSecondary = meetsThreshold(secondaryThresh, secondaryVal);
      }
      
      let rating = 'average';
      let ratingText = 'Average';
      let ratingClass = 'rating-avg';
      
      if (meetsSuccess && meetsSecondary) {
        rating = 'above';
        ratingText = 'Above Average';
        ratingClass = 'rating-above';
      } else if (meetsFailure || !meetsSecondary) {
        rating = 'below';
        ratingText = 'Below Average';
        ratingClass = 'rating-below';
      }
      
      return {
        rating,
        ratingText,
        ratingClass,
        meetsSuccess,
        meetsFailure,
        meetsSecondary
      };
    }

    function normalizeValue(unit, raw) {
      if (raw === '' || raw == null) return null;
      if (typeof raw === 'boolean') return raw;
      
      const u = String(unit || '').toLowerCase();
      
      if (u.includes('bool') || u === 'boolean') {
        if (typeof raw === 'string') {
          return /^(yes|true|1)$/i.test(raw.trim());
        }
        return !!raw;
      }
      
      const num = parseFloat(raw);
      if (!isNaN(num)) {
        return num;
      }
      
      return raw;
    }

    // timers
    function makeTimer(timeEl, onState){
      let running=false, t0=0, acc=0, raf=null;
      const fmt = ms => (ms/1000).toFixed(2);
      const tick = ()=>{ 
        const now=performance.now(); 
        const ms=acc + (running ? (now-t0) : 0); 
        timeEl.textContent = fmt(ms); 
        if(running) raf=requestAnimationFrame(tick); 
      };
      const start = ()=>{ 
        if(running) return; 
        running=true; 
        t0=performance.now(); 
        tick(); 
        onState?.(true); 
      };
      const stop  = ()=>{ 
        if(!running) return; 
        running=false; 
        acc += performance.now()-t0; 
        cancelAnimationFrame(raf); 
        tick(); 
        onState?.(false); 
      };
      const reset = ()=>{ 
        running=false; 
        acc=0; 
        cancelAnimationFrame(raf); 
        tick(); 
        onState?.(false); 
      };
      const toggle= ()=> running ? stop() : start();
      const read = ()=> parseFloat(timeEl.textContent || '0');
      tick();
      return { start, stop, reset, toggle, isRunning:()=>running, read };
    }

    // roster datalist
    async function loadRoster(){
      const res = await API.tryout.read.roster();
      if(!res?.ok) return;
      const tid = ctx().tryout_id || '';
      roster = (res.roster||[]).filter(r => !tid || String(r.tryout_id||'')===String(tid));
      const dl = document.getElementById('qb_roster');
      dl.innerHTML = '';
      roster.forEach(r=>{
        const rec = {
          player_id: r.player_id || '',
          display_name: r.display_name || r.player_name || '',
          primary_pos: r.primary_pos || r.position || '',
          tryout_num: r.tryout_num || r.jersey_number || '',
          group_code: r.group_code || r.primary_pos || ''
        };
        const opt = document.createElement('option');
        opt.value = labelFor(rec);
        opt.dataset.pid = rec.player_id;
        dl.appendChild(opt);
      });
    }

    async function loadLatestGroups(){
      const res = await API.tryout.read.groupsLatest(ctx().tryout_id);
      if(!res?.ok || !Array.isArray(res.latest)) return;
      groupLatest.clear();
      res.latest.forEach(row => { 
        if(row.player_id && row.group_code) 
          groupLatest.set(String(row.player_id).trim(), String(row.group_code).trim()); 
      });
    }

    function resolveGroupCode(pid, fallback, rec){
      if (pid) {
        const direct = groupLatest.get(String(pid).trim());
        if (direct) return direct;
        const r = roster.find(x => String(x.player_id).trim() === String(pid).trim());
        return r?.group_code || r?.primary_pos || fallback || '';
      }
      return rec?.group_code || rec?.primary_pos || fallback || '';
    }

    // Active lane highlight
    function setActiveLane(l){
      activeLane = (l==='B') ? 'B' : 'A';
      document.getElementById('segA').setAttribute('aria-pressed', activeLane==='A' ? 'true':'false');
      document.getElementById('segB').setAttribute('aria-pressed', activeLane==='B' ? 'true':'false');
      qs('#laneA').classList.toggle('lane-active', activeLane==='A');
      qs('#laneB').classList.toggle('lane-active', activeLane==='B');
    }
    document.getElementById('segA').addEventListener('click', ()=> setActiveLane('A'));
    document.getElementById('segB').addEventListener('click', ()=> setActiveLane('B'));
    qs('#laneA').addEventListener('click', ()=> setActiveLane('A'));
    qs('#laneB').addEventListener('click', ()=> setActiveLane('B'));

    // Resets
    function softResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Time`).textContent = '0.00';
      const t = timers.get(p); 
      t && t.reset();
      const box = qs(`#${p}InputsBlock`);
      if (box) {
        box.querySelectorAll('[data-counter-value]').forEach(el => {
          el.textContent = '0';
        });
        box.querySelectorAll('input[type="checkbox"]').forEach(el => {
          el.checked = false;
        });
        // Update rate displays
        box.querySelectorAll('.rate-display .rate-value').forEach(el => {
          el.textContent = '0%';
        });
        // Update count displays
        box.querySelectorAll('[id$="SuccCount"], [id$="AttCount"]').forEach(el => {
          el.textContent = '0';
        });
      }
      qs(`#${p}Status`).textContent = '';
    }

    function hardResetLane(lane){
      const p = lane==='A' ? 'a' : 'b';
      qs(`#${p}Attempt`).value = '1';
      qs(`#${p}Log`).innerHTML = '';
      qs(`#${p}Extra1`).value = '';
      qs(`#${p}Extra2`).value = '';
      softResetLane(lane);
    }

    function renderLaneChips(){
      const a = lanePlayers.A, b = lanePlayers.B;
      const aEl = document.getElementById('laneAWho');
      const bEl = document.getElementById('laneBWho');
      const topA= document.getElementById('chipLaneA');
      const topB= document.getElementById('chipLaneB');

      if(a){
        const txt = `${a.tryout_num||''} • ${a.display_name||a.player_id}${a.primary_pos?` (${a.primary_pos})`:''}`;
        aEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="A">✕</span>`;
        aEl.style.display = '';
        topA.textContent = `Lane A: ${txt}`; topA.style.display = '';
        document.getElementById('aSave').disabled = false;
      } else {
        aEl.style.display = 'none'; topA.style.display = 'none';
        document.getElementById('aSave').disabled = true;
      }
      if(b){
        const txt = `${b.tryout_num||''} • ${b.display_name||b.player_id}${b.primary_pos?` (${b.primary_pos})`:''}`;
        bEl.innerHTML = `${txt} <span class="x" title="Clear" aria-label="Clear" data-clear="B">✕</span>`;
        bEl.style.display = '';
        topB.textContent = `Lane B: ${txt}`; topB.style.display = '';
        document.getElementById('bSave').disabled = false;
      } else {
        bEl.style.display = 'none'; topB.style.display = 'none';
        document.getElementById('bSave').disabled = true;
      }

      document.querySelectorAll('[data-clear="A"]').forEach(x=> x.onclick = ()=>{ 
        lanePlayers.A = null; 
        renderLaneChips(); 
        hardResetLane('A'); 
      });
      document.querySelectorAll('[data-clear="B"]').forEach(x=> x.onclick = ()=>{ 
        lanePlayers.B = null; 
        renderLaneChips(); 
        hardResetLane('B'); 
      });
    }

    // Assign to active lane
    function assignToActiveLane(rec){
      lanePlayers[activeLane] = rec;
      document.getElementById('playerPicker').value = labelFor(rec);
      renderLaneChips();
      hardResetLane(activeLane);
    }

    // Selection sources
    window.addEventListener('tryoutui:select', (e)=>{
      const d = e?.detail?.player; 
      if(!d) return;
      const hit = roster.find(r => r.player_id===d.player_id) || d;
      assignToActiveLane(hit);
    });

    document.getElementById('playerPicker').addEventListener('change', (e)=>{
      const txt = (e.target.value||'').toLowerCase();
      const hit = roster.find(r => labelFor(r).toLowerCase() === txt) ||
                  roster.find(r => String(r.tryout_num||'').toLowerCase() === txt) ||
                  roster.find(r => String(r.display_name||'').toLowerCase() === txt);
      if(hit) assignToActiveLane(hit);
    });

    // ---- Drill Dictionary hookup ----
    function renderInputs(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      const timerBlk = qs(`#${prefix}TimerBlock`);
      const inputBlk = qs(`#${prefix}InputsBlock`);
      const bothCard = qs('#bothStartCard');
      const primaryLabel = qs(`#${prefix}PrimaryLabel`);
      const primaryHelp = qs(`#${prefix}PrimaryHelp`);

      // Update primary label - show what we're measuring
      const primLabel = isRate ? `${drill.primary_measurement} (calculated %)` : (drill.primary_measurement || 'Time');
      primaryLabel.textContent = primLabel;
      
      // Add helpful description
      let helpText = '';
      if (drill.drill_category) {
        helpText += drill.drill_category + ' • ';
      }
      if (drill.success_threshold) {
        helpText += `Above Avg: ${drill.success_threshold}`;
      }
      if (drill.failure_threshold) {
        helpText += ` • Below Avg: ${drill.failure_threshold}`;
      }
      primaryHelp.textContent = helpText;

      // Toggle timer vs inputs
      timerBlk.style.display = isTime ? '' : 'none';
      inputBlk.style.display = isTime ? 'none' : '';

      // Update headings/labels
      const head = qs(`#${prefix}Head`);
      head.innerHTML = `<tr>
        <th>Drill</th><th>Att</th>
        <th>${drill.primary_measurement || 'Primary'}</th>
        <th>${drill.secondary_measurement || 'Secondary'}</th>
        <th>Rating</th>
      </tr>`;

      // Start Both visible only for time drills
      bothCard.style.display = isTime ? '' : 'none';

      // Build inputs if not time
      inputBlk.innerHTML = '';
      if (!isTime) {
        // For Rate drills: show successes and failures
        if (isRate) {
          const succId = `${prefix}Successes`;
          const failId = `${prefix}Failures`;
          const rateDisplayId = `${prefix}RateDisplay`;

          // Determine labels based on measurement name
          let successLabel = 'Successes';
          let failureLabel = 'Failures';
          const meas = String(drill.primary_measurement || '').toLowerCase();
          
          if (meas.includes('error')) {
            successLabel = 'Clean Reps';
            failureLabel = 'Errors';
          } else if (meas.includes('completion')) {
            successLabel = 'Completions';
            failureLabel = 'Incompletions';
          } else if (meas.includes('catch')) {
            successLabel = 'Catches';
            failureLabel = 'Drops';
          } else if (meas.includes('win')) {
            successLabel = 'Wins';
            failureLabel = 'Losses';
          } else if (meas.includes('clean') || meas.includes('perfect')) {
            successLabel = 'Clean Reps';
            failureLabel = 'Errors';
          } else if (meas.includes('correct')) {
            successLabel = 'Correct Reps';
            failureLabel = 'Incorrect';
          } else if (meas.includes('break')) {
            successLabel = 'Good Breaks';
            failureLabel = 'Bad Breaks';
          }

          inputBlk.innerHTML = `
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:12px;">
              <div>
                <label class="label">${successLabel}</label>
                <div class="measure-help">Good reps</div>
                <div class="counter-control">
                  <button class="counter-btn" data-counter-dec="${succId}" type="button">−</button>
                  <div class="counter-value" data-counter-value="${succId}">0</div>
                  <button class="counter-btn" data-counter-inc="${succId}" type="button">+</button>
                </div>
              </div>
              <div>
                <label class="label">${failureLabel}</label>
                <div class="measure-help">Bad reps</div>
                <div class="counter-control">
                  <button class="counter-btn" data-counter-dec="${failId}" type="button">−</button>
                  <div class="counter-value" data-counter-value="${failId}">0</div>
                  <button class="counter-btn" data-counter-inc="${failId}" type="button">+</button>
                </div>
              </div>
            </div>
            <div class="rate-display">
              <div class="rate-value" id="${rateDisplayId}">0%</div>
              <div class="rate-label">${drill.primary_measurement || 'Success Rate'} (${successLabel}: <span id="${prefix}SuccCount">0</span> / Attempts: <span id="${prefix}AttCount">0</span>)</div>
            </div>
          `;

          // Wire up counter buttons and auto-calculate rate
          const updateRate = () => {
            const succEl = inputBlk.querySelector(`[data-counter-value="${succId}"]`);
            const failEl = inputBlk.querySelector(`[data-counter-value="${failId}"]`);
            const rateEl = inputBlk.querySelector(`#${rateDisplayId}`);
            const succCountEl = inputBlk.querySelector(`#${prefix}SuccCount`);
            const attCountEl = inputBlk.querySelector(`#${prefix}AttCount`);
            
            const succ = parseInt(succEl?.textContent || '0');
            const fail = parseInt(failEl?.textContent || '0');
            const att = succ + fail;
            
            const rate = att > 0 ? ((succ / att) * 100).toFixed(1) : 0;
            rateEl.textContent = `${rate}%`;
            if (succCountEl) succCountEl.textContent = String(succ);
            if (attCountEl) attCountEl.textContent = String(att);
          };

          inputBlk.querySelectorAll('[data-counter-inc]').forEach(btn => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-counter-inc');
              const valueEl = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const current = parseInt(valueEl.textContent) || 0;
              valueEl.textContent = String(current + 1);
              updateRate();
            });
          });

          inputBlk.querySelectorAll('[data-counter-dec]').forEach(btn => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-counter-dec');
              const valueEl = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const current = parseInt(valueEl.textContent) || 0;
              if (current > 0) {
                valueEl.textContent = String(current - 1);
                updateRate();
              }
            });
          });

          // Add secondary measurement if exists
          if (drill.secondary_measurement) {
            const secId = `${prefix}SecVal`;
            let secHelp = drill.secondary_threshold ? `Target: ${drill.secondary_threshold}` : '';
            
            const secHTML = `
              <div style="margin-top:12px;">
                <label class="label">${drill.secondary_measurement}</label>
                <div class="measure-help">${secHelp}</div>
                <div class="counter-control">
                  <button class="counter-btn" data-counter-dec="${secId}" type="button">−</button>
                  <div class="counter-value" data-counter-value="${secId}">0</div>
                  <button class="counter-btn" data-counter-inc="${secId}" type="button">+</button>
                </div>
              </div>
            `;
            inputBlk.insertAdjacentHTML('beforeend', secHTML);

            // Wire secondary counter
            inputBlk.querySelectorAll(`[data-counter-inc="${secId}"], [data-counter-dec="${secId}"]`).forEach(btn => {
              const isInc = btn.hasAttribute('data-counter-inc');
              btn.addEventListener('click', () => {
                const valueEl = inputBlk.querySelector(`[data-counter-value="${secId}"]`);
                const current = parseInt(valueEl.textContent) || 0;
                if (isInc) {
                  valueEl.textContent = String(current + 1);
                } else if (current > 0) {
                  valueEl.textContent = String(current - 1);
                }
              });
            });
          }
        } else {
          // Non-rate, non-time drills: use regular counters or toggles
          const makeCounter = (id, label, help='') => `
            <div>
              <label class="label">${label}</label>
              ${help ? `<div class="measure-help">${help}</div>` : ''}
              <div class="counter-control">
                <button class="counter-btn" data-counter-dec="${id}" type="button">−</button>
                <div class="counter-value" data-counter-value="${id}">0</div>
                <button class="counter-btn" data-counter-inc="${id}" type="button">+</button>
              </div>
            </div>`;
          
          const makeToggle = (id, label, help='') => `
            <div>
              <label class="label" style="margin-bottom:8px">${label}</label>
              ${help ? `<div class="measure-help" style="margin-bottom:6px">${help}</div>` : ''}
              <label class="toggle-switch">
                <input type="checkbox" id="${id}">
                <span class="toggle-slider"></span>
                <span class="toggle-label">Yes</span>
              </label>
            </div>`;

          const primId = `${prefix}PrimVal`;
          const secId = `${prefix}SecVal`;

          const primIsBool = /bool/i.test(drill.measurement_unit||'') || 
                            (String(drill.measurement_unit||'').toLowerCase()==='boolean');

          let primHelp = drill.success_threshold ? `Target: ${drill.success_threshold}` : '';
          inputBlk.innerHTML += (primIsBool
            ? makeToggle(primId, drill.primary_measurement || 'Primary', primHelp)
            : makeCounter(primId, drill.primary_measurement || 'Primary', primHelp));

          if (drill.secondary_measurement) {
            const secIsBool = /bool/i.test(drill.secondary_unit||'') || 
                             (String(drill.secondary_unit||'').toLowerCase()==='boolean');
            let secHelp = drill.secondary_threshold ? `Target: ${drill.secondary_threshold}` : '';
            inputBlk.innerHTML += (secIsBool
              ? makeToggle(secId, drill.secondary_measurement, secHelp)
              : makeCounter(secId, drill.secondary_measurement, secHelp));
          }

          // Wire up counter buttons
          inputBlk.querySelectorAll('[data-counter-inc]').forEach(btn => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-counter-inc');
              const valueEl = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const current = parseInt(valueEl.textContent) || 0;
              valueEl.textContent = String(current + 1);
            });
          });

          inputBlk.querySelectorAll('[data-counter-dec]').forEach(btn => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-counter-dec');
              const valueEl = inputBlk.querySelector(`[data-counter-value="${id}"]`);
              const current = parseInt(valueEl.textContent) || 0;
              if (current > 0) {
                valueEl.textContent = String(current - 1);
              }
            });
          });
        }
      }
    }

    async function loadQBDrills(){
      try {
        const res = await API.tryout.read.drills();
        if (res?.ok) {
          const allDrills = res.drills || res.rows || [];
          QB_DRILLS = allDrills.filter(d => {
            const pg = String(d.position_group || '').toUpperCase();
            const st = String(d.station_id || '').toUpperCase();
            return pg === 'QB' || st === 'QB' || st === 'QBS';
          });
        }
      } catch (e) {
        console.error('Error loading drills:', e);
      }

      // Fallback if no drills loaded
      if (!Array.isArray(QB_DRILLS) || !QB_DRILLS.length) {
        QB_DRILLS = [
          { 
            drill_id: 'QB01', 
            drill_name: 'Pocket Presence',
            station_id: 'QB',
            position_group: 'QB',
            drill_type: 'Rate',
            primary_measurement: 'success_rate',
            measurement_unit: 'percentage',
            success_threshold: '>=80',
            failure_threshold: '<=50',
            secondary_measurement: 'errors',
            secondary_unit: 'count',
            secondary_threshold: '<=1'
          }
        ];
      }

      const sel = document.getElementById('qbDrillSel');
      sel.innerHTML = QB_DRILLS.map(d => 
        `<option value="${d.drill_id}">${d.drill_name}</option>`
      ).join('');
      
      if (QB_DRILLS[0]) {
        sel.value = QB_DRILLS[0].drill_id;
      }
      
      sel.dispatchEvent(new Event('change'));
    }

    // Wire drill selection
    document.getElementById('qbDrillSel').addEventListener('change', ()=>{
      const sel = document.getElementById('qbDrillSel');
      QB_CURR = QB_DRILLS.find(x => x.drill_id === sel.value) || null;
      const badge = document.getElementById('drillBadge');
      const hint  = document.getElementById('qbDrillHint');
      
      if (QB_CURR){
        badge.textContent = `Drill: ${QB_CURR.drill_name}`;
        
        const hintParts = [];
        if (QB_CURR.drill_category) hintParts.push(QB_CURR.drill_category);
        if (QB_CURR.success_threshold) {
          hintParts.push(`Above Avg: ${QB_CURR.success_threshold}`);
        }
        if (QB_CURR.failure_threshold) {
          hintParts.push(`Below Avg: ${QB_CURR.failure_threshold}`);
        }
        
        hint.textContent = hintParts.join(' • ');
        
        renderInputs('a', QB_CURR);
        renderInputs('b', QB_CURR);
        softResetLane('A'); 
        softResetLane('B');
      } else {
        badge.textContent = 'Drill: —'; 
        hint.textContent = '';
      }
    });

    // ----- Recent writes (bottom) -----
    function addRecent(route, summary){
      pageLog.unshift({ ts:new Date(), route, summary });
      pageLog.splice(PAGE_LOG_LIMIT);
      renderRecent();
    }

    function renderRecent(){
      const ul = qs('#recentList');
      const cnt = qs('#recentCount');
      if (!ul) return;
      ul.innerHTML = pageLog.map(it => 
        `<li><strong>${fmtTime(it.ts)}</strong> — ${it.summary}</li>`
      ).join('');
      cnt.textContent = pageLog.length ? `${pageLog.length} item${pageLog.length===1?'':'s'}` : '';
    }

    qs('#toggleRecent').addEventListener('click', ()=>{
      const p = qs('#recentPanel');
      const open = p.style.display !== 'none';
      p.style.display = open ? 'none' : '';
      qs('#toggleRecent').textContent = open ? 'Recent Writes ▾' : 'Recent Writes ▴';
    });

    /* -------- Saving indicator helpers -------- */
    function setSaving(lane, saving){
      const p = (lane==='A') ? 'a' : 'b';
      const saveBtn = document.getElementById(p+'Save');
      const toggleBtn = document.getElementById(p+'Toggle');
      const resetBtn = document.getElementById(p+'Reset');

      if (!saveBtn.dataset.label) saveBtn.dataset.label = saveBtn.textContent;

      if (saving){
        saveBtn.classList.add('loading');
        saveBtn.disabled = true;
        if (toggleBtn) toggleBtn.disabled = true;
        if (resetBtn) resetBtn.disabled = true;
        saveBtn.innerHTML = '<span class="spin"></span>Saving…';
      } else {
        saveBtn.classList.remove('loading');
        saveBtn.disabled = (lane==='A' ? !lanePlayers.A : !lanePlayers.B);
        if (toggleBtn) toggleBtn.disabled = false;
        if (resetBtn) resetBtn.disabled = false;
        saveBtn.textContent = saveBtn.dataset.label || 'Save';
      }
    }

    function readLaneValues(prefix, drill){
      const isTime = isTimeDrill(drill);
      const isRate = isRateDrill(drill);
      let primaryVal = null, secondaryVal = null;

      if (isTime){
        const timeEl = qs(`#${prefix}Time`);
        primaryVal = parseFloat((timeEl.textContent||'0').trim());
        if (isNaN(primaryVal)) primaryVal = null;
      } else if (isRate) {
        // Read successes and failures, calculate percentage
        const box = qs(`#${prefix}InputsBlock`);
        const succEl = box?.querySelector(`[data-counter-value="${prefix}Successes"]`);
        const failEl = box?.querySelector(`[data-counter-value="${prefix}Failures"]`);
        const secEl = box?.querySelector(`[data-counter-value="${prefix}SecVal"]`);
        
        const succ = parseInt(succEl?.textContent || '0');
        const fail = parseInt(failEl?.textContent || '0');
        const att = succ + fail;
        
        // Calculate percentage
        primaryVal = att > 0 ? ((succ / att) * 100) : 0;
        
        // Read secondary (usually errors/drops as count)
        if (secEl) {
          secondaryVal = parseInt(secEl.textContent || '0');
        }
      } else {
        const box = qs(`#${prefix}InputsBlock`);
        const primId = `${prefix}PrimVal`;
        const secId  = `${prefix}SecVal`;
        
        const primCounter = box?.querySelector(`[data-counter-value="${primId}"]`);
        const primToggle = box?.querySelector(`#${primId}`);
        const secCounter = box?.querySelector(`[data-counter-value="${secId}"]`);
        const secToggle = box?.querySelector(`#${secId}`);
        
        if (primCounter) {
          primaryVal = parseInt(primCounter.textContent) || 0;
        } else if (primToggle) {
          primaryVal = primToggle.checked;
        }
        
        if (secCounter) {
          secondaryVal = parseInt(secCounter.textContent) || 0;
        } else if (secToggle) {
          secondaryVal = secToggle.checked;
        }
        
        primaryVal = normalizeValue(drill.measurement_unit, primaryVal);
        secondaryVal = secondaryVal != null ? normalizeValue(drill.secondary_unit, secondaryVal) : null;
      }
      return { primaryVal, secondaryVal, isTime, isRate };
    }

    async function saveAttempt({ lane }){
      const prefix   = lane==='A' ? 'a' : 'b';
      const statusEl = document.getElementById(lane==='A' ? 'aStatus' : 'bStatus');
      const attSel   = document.getElementById(lane==='A' ? 'aAttempt': 'bAttempt');
      const logTbody = document.getElementById(lane==='A' ? 'aLog'    : 'bLog');

      statusEl.textContent = '';

      const c = ctx();
      if(!c.tryout_id){ 
        statusEl.textContent='Set a Tryout ID first.'; 
        statusEl.className='status warn'; 
        return; 
      }
      if(!QB_CURR){ 
        statusEl.textContent='Choose a drill.'; 
        statusEl.className='status warn'; 
        return; 
      }

      const player = lanePlayers[lane];
      if(!(player?.tryout_num || player?.player_id)){
        statusEl.textContent=`Assign a player to Lane ${lane}.`;
        statusEl.className='status warn';
        return;
      }

      // Ensure timer stopped before read
      const t = timers.get(prefix);
      if (t?.isRunning()) t.stop();

      const { primaryVal, secondaryVal, isTime, isRate } = readLaneValues(prefix, QB_CURR);
      const attempt = Number(attSel.value||1);

      // Evaluate drill performance
      const evaluation = evaluateDrill(QB_CURR, primaryVal, secondaryVal);

      const row = {
        tryout_id:   c.tryout_id || '',
        period_code: c.period_code || '',
        tryout_num:  String(player.tryout_num || '').trim(),
        player_id:   String(player.player_id || '').trim(),
        group_code:  resolveGroupCode(player.player_id, '', player) || '',
        station_id:  STATION_ID,
        drill_id:    QB_CURR.drill_id,
        attempt:     attempt,
        metric_1:    (primaryVal===true)?1:(primaryVal===false)?0:primaryVal,
        metric_2:    (secondaryVal===true)?1:(secondaryVal===false)?0:secondaryVal,
        pass_flag:   evaluation.rating === 'above' ? 1 : 0,
        notes:       (document.getElementById('sharedNotes').value||'').trim(),
        extra_1:     (document.getElementById(prefix+'Extra1').value||'').trim(),
        extra_2:     (document.getElementById(prefix+'Extra2').value||'').trim()
      };

      setSaving(lane, true);
      let res;
      try { 
        res = await API.tryout.write.station(row); 
      } finally { 
        setSaving(lane, false); 
      }

      if(!res?.ok){
        statusEl.textContent = res?.error || 'Save failed.';
        statusEl.className = 'status err';
        return;
      }

      // Add to lane log
      const primTxt = primaryVal==null ? '—' : 
                     (isTime ? Number(primaryVal).toFixed(2)+' s' : 
                      isRate ? Number(primaryVal).toFixed(1)+'%' : String(primaryVal));
      const secTxt  = (QB_CURR.secondary_measurement ? 
                      (secondaryVal==null ? '—' : String(secondaryVal)) : '—');
      
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${QB_CURR.drill_name}</td>
        <td>${attempt}</td>
        <td>${primTxt}</td>
        <td>${secTxt}</td>
        <td><span class="${evaluation.ratingClass}">${evaluation.ratingText}</span></td>`;
      logTbody.prepend(tr);
      while(logTbody.children.length > 10) logTbody.removeChild(logTbody.lastChild);

      // Recent Writes
      const who = player.tryout_num || player.player_id || '—';
      addRecent('station', 
        `Write → QB :: ${who} • ${QB_CURR.drill_name} • ${primTxt}${QB_CURR.secondary_measurement?` • ${secTxt}`:''} • ${evaluation.ratingText} (Att ${attempt})`
      );

      // Mark done
      if (AFTER_SAVE.markDone) {
        try { 
          TryoutUI?.markDone?.(player.player_id || player.tryout_num); 
        } catch {}
        try { 
          window.dispatchEvent(new CustomEvent('tryoutui:done', { 
            detail:{ player_id: player.player_id, tryout_num: player.tryout_num } 
          })); 
        } catch {}
      }

      // Auto-increment attempt (like agility)
      const next = Math.min((attempt % 10) + 1, 10);
      attSel.value = String(next);
      softResetLane(lane);

      // Status message
      statusEl.textContent = `Saved ✔ • ${evaluation.ratingText}`;
      statusEl.className = evaluation.rating === 'above' ? 'status ok' : 
                          evaluation.rating === 'below' ? 'status warn' : 'status avg';
    }

    // Wire lanes
    function wireLane(prefix){
      const toggleBtn = document.getElementById(prefix+'Toggle');
      const timeEl = document.getElementById(prefix+'Time');
      const statusEl = document.getElementById(prefix+'Status');

      const t = makeTimer(timeEl, (running)=>{
        if (toggleBtn){
          toggleBtn.textContent = running ? 'Stop' : 'Start';
          toggleBtn.setAttribute('aria-pressed', running ? 'true' : 'false');
          toggleBtn.classList.toggle('warn', running);
        }
        if (!running) statusEl.textContent = '';
      });
      timers.set(prefix, t);

      if (toggleBtn) toggleBtn.addEventListener('click', t.toggle);
      
      const resetBtn = document.getElementById(prefix+'Reset');
      if (resetBtn) resetBtn.addEventListener('click', ()=>{
        softResetLane(prefix === 'a' ? 'A' : 'B');
      });
      
      document.getElementById(prefix+'Save').addEventListener('click', ()=>{
        saveAttempt({ lane: (prefix==='a'?'A':'B') });
      });
    }

    // Start both timers
    function wireBothStart(){
      const a = () => timers.get('a');
      const b = () => timers.get('b');
      const btn = document.getElementById('bothStart');
      if (!btn) return;
      btn.addEventListener('click', ()=>{ 
        if(lanePlayers.A) a()?.start(); 
        if(lanePlayers.B) b()?.start(); 
      });
    }

    // Init
    (async function init(){
      wireLane('a');
      wireLane('b');
      wireBothStart();
      setActiveLane('A');
      
      await Promise.all([
        loadRoster(), 
        loadLatestGroups(), 
        loadQBDrills()
      ]);

      // If TryoutUI has an active selection, use it
      if (window.TryoutUI?.getSelectedPlayers) {
        const cur = TryoutUI.getSelectedPlayers();
        if (Array.isArray(cur) && cur[0]) {
          assignToActiveLane(cur[0]);
        }
      }
    })();
  </script>
</body>
</html>